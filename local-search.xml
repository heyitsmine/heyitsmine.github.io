<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Ubuntu 20.04 clash for linux 配置</title>
    <link href="/2021/08/22/clash/"/>
    <url>/2021/08/22/clash/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><p><a href="https://swing1993.cn/clashzi-dong-geng-xin-ding-yue-pei-zhi/amp/">ClashForLinux自动更新订阅配置</a></p><p><a href="https://ytlee.cn/2021/04/clash-for-linux-automatically-renews-the-subscription-link/">Clash For Linux自动更新订阅配置</a></p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>通过systemctl来管理Clash的进程，对应<code>clash.service</code>文件，通过两个脚本<code>start-clash.sh</code>和<code>stop-clash.sh</code>来管理Clash的启停，具体配置如下。</p><h2 id="clash-service"><a href="#clash-service" class="headerlink" title="clash.service"></a>clash.service</h2><p>置于<code>/lib/systemd/system/clash.service</code>，注意修改用户名和订阅链接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>Description=clash daemon<br>After=network.target<br><br>[Service]<br>Type=simple<br>User=tangger<br>ExecStart=/home/&lt;用户名&gt;/.config/clash/start-clash.sh<br>ExecStop=/home/&lt;用户名&gt;/.config/clash/stop-clash.sh<br>Environment=&quot;HOME=/home/&lt;用户名&gt;/&quot;<br>Environment=&quot;CLASH_URL=&lt;填入您的订阅链接&gt;&quot;<br><br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><h2 id="start-clash-sh"><a href="#start-clash-sh" class="headerlink" title="start-clash.sh"></a>start-clash.sh</h2><p>置于<code>$&#123;HOME&#125;/.config/clash/start-clash.sh</code>，注意修改用户名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash"> save this file to <span class="hljs-variable">$&#123;HOME&#125;</span>/.config/clash/start-clash.sh</span><br><br><span class="hljs-meta">#</span><span class="bash"> save pid file</span><br>echo $$ &gt; $&#123;HOME&#125;/.config/clash/clash.pid<br><br>diff $&#123;HOME&#125;/.config/clash/config.yaml &lt;(curl -s $&#123;CLASH_URL&#125;)<br>if [ &quot;$?&quot; == 0 ]<br>then<br>    /usr/local/bin/clash -d /home/&lt;用户名&gt;/.config/clash/<br>else<br>    curl -L -o $&#123;HOME&#125;/.config/clash/config.yaml $&#123;CLASH_URL&#125;<br>    /usr/local/bin/clash -d /home/&lt;用户名&gt;/.config/clash/<br>fi<br></code></pre></td></tr></table></figure><h2 id="stop-clash-sh"><a href="#stop-clash-sh" class="headerlink" title="stop-clash.sh"></a>stop-clash.sh</h2><p>置于<code>$&#123;HOME&#125;/.config/clash/stop-clash.sh</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br><span class="hljs-meta">#</span><span class="bash"> save this file to <span class="hljs-variable">$&#123;HOME&#125;</span>/.config/clash/stop-clash.sh</span><br><br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">read</span> pid file</span><br>PID=`cat $&#123;HOME&#125;/.config/clash/clash.pid`<br>kill -9 $&#123;PID&#125;<br>rm $&#123;HOME&#125;/.config/clash/clash.pid<br></code></pre></td></tr></table></figure><h2 id="赋予执行权限"><a href="#赋予执行权限" class="headerlink" title="赋予执行权限"></a>赋予执行权限</h2><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x $&#123;HOME&#125;/.config/clash/start-clash.sh<br>chmod +x $&#123;HOME&#125;/.config/clash/stop-clash.sh<br></code></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable clash<br>systemctl start clash<br></code></pre></td></tr></table></figure><p><code>ps -ef | grep clash</code>验证下clash是否已在运行，Setting - Network中配置Network Proxy，然后访问网页测试。没问题的话，clash将开机自动启动，并自动更新配置。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>clash二进制文件放在<code>/usr/local/bin/</code></li><li>注意文件路径</li><li>.sh记得加执行权限</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wls2 Ubuntu配置</title>
    <link href="/2021/04/15/zsh-configuration/"/>
    <url>/2021/04/15/zsh-configuration/</url>
    
    <content type="html"><![CDATA[<p>主要参考<a href="https://zhuanlan.zhihu.com/p/345559097">https://zhuanlan.zhihu.com/p/345559097</a></p><h1 id="在Ubuntu安装Zsh"><a href="#在Ubuntu安装Zsh" class="headerlink" title="在Ubuntu安装Zsh"></a>在Ubuntu安装Zsh</h1><p>终端里面输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install zsh<br></code></pre></td></tr></table></figure><h1 id="安装插件和主题"><a href="#安装插件和主题" class="headerlink" title="安装插件和主题"></a>安装插件和主题</h1><p>插件：</p><ul><li><code>zsh-autosuggestions</code>：这个是自动建议插件，能够自动提示你需要的命令。</li><li><code>zsh-syntax-highlighting</code>：这个是代码高亮插件，能够使你的命令行各个命令清晰明了。</li></ul><p>终端里面输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install zsh-autosuggestions zsh-syntax-highlighting<br></code></pre></td></tr></table></figure><p>主题：</p><ul><li><code>zsh-theme-powerlevel10k</code> 这个主题提供漂亮的提示符，可以显示当前路径、时间、命令执行成功与否，还能够支持 git 分支显示等等。安装过程参见：<a href="https://github.com/romkatv/powerlevel10k">https://github.com/romkatv/powerlevel10k</a></li></ul><h1 id="更改默认-shell"><a href="#更改默认-shell" class="headerlink" title="更改默认 shell"></a>更改默认 shell</h1><p>终端输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chsh -s /usr/bin/zsh<br></code></pre></td></tr></table></figure><h1 id="在-Ubuntu-启用插件"><a href="#在-Ubuntu-启用插件" class="headerlink" title="在 Ubuntu 启用插件"></a>在 Ubuntu 启用插件</h1><p>打开 <code>~/.zshrc</code> 文件，将以下行代码添加到其中：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">source /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh<br>source /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh<br></code></pre></td></tr></table></figure><h1 id="启用历史输入搜索"><a href="#启用历史输入搜索" class="headerlink" title="启用历史输入搜索"></a>启用历史输入搜索</h1><p>在<code>~/.zshrc</code> 文件添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bindkey &#x27;^R&#x27; history-incremental-search-backward<br></code></pre></td></tr></table></figure><h1 id="wsl2设置Windows代理"><a href="#wsl2设置Windows代理" class="headerlink" title="wsl2设置Windows代理"></a>wsl2设置Windows代理</h1><p><a href="https://zhuanlan.zhihu.com/p/153124468">https://zhuanlan.zhihu.com/p/153124468</a></p><p>打开<code>/etc/zsh/zshenv</code>文件，将以下两行添加到末尾</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">host_ip=$(cat /etc/resolv.conf |grep &quot;nameserver&quot; |cut -f 2 -d &quot; &quot;)<br>export ALL_PROXY=&quot;http://$host_ip:7890&quot;<br></code></pre></td></tr></table></figure><h1 id="自动将wsl2-Ubuntu-ip写入Windows-hosts文件"><a href="#自动将wsl2-Ubuntu-ip写入Windows-hosts文件" class="headerlink" title="自动将wsl2 Ubuntu ip写入Windows hosts文件"></a>自动将wsl2 Ubuntu ip写入Windows hosts文件</h1><p><a href="https://github.com/shayne/go-wsl2-host">https://github.com/shayne/go-wsl2-host</a></p><h1 id="wsl2自动启动ssh-server"><a href="#wsl2自动启动ssh-server" class="headerlink" title="wsl2自动启动ssh server"></a>wsl2自动启动ssh server</h1><p><a href="https://gist.github.com/dentechy/de2be62b55cfd234681921d5a8b6be11">https://gist.github.com/dentechy/de2be62b55cfd234681921d5a8b6be11</a></p><p><a href="https://www.illuminiastudios.com/dev-diaries/ssh-on-windows-subsystem-for-linux/">https://www.illuminiastudios.com/dev-diaries/ssh-on-windows-subsystem-for-linux/</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在prototypical network中加入注意力机制</title>
    <link href="/2020/11/09/protonet-with-attention/"/>
    <url>/2020/11/09/protonet-with-attention/</url>
    
    <content type="html"><![CDATA[<h1 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h1><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td><script type="math/tex">x</script></td><td>样本（句子）</td></tr><tr><td><script type="math/tex">\mathrm{x}</script></td><td></td></tr><tr><td><script type="math/tex">w_t</script></td><td>句子中第t个单词</td></tr><tr><td><script type="math/tex">\mathrm{w}_t\in\mathbb{R}^{d_w}</script></td><td>句子中第t个单词的词向量</td></tr><tr><td><script type="math/tex">\mathrm{p}_t\in\mathbb{R}^{2\times d_p}</script></td><td>句子中第t个单词的相对两个实体的位置编码</td></tr><tr><td><script type="math/tex">d_w,d_p,d_c</script></td><td>词向量维度，位置编码维度,CNN卷积核维度</td></tr><tr><td><script type="math/tex">\mathrm{e}_t</script></td><td>句子中第t个单词的向量表示</td></tr><tr><td><script type="math/tex">\mathrm{W}\in\mathbb{R}^{T\times(d_w+2d_p)}</script></td><td>长度为<script type="math/tex">T</script>的单个样本的向量表示</td></tr><tr><td><script type="math/tex">\mathrm{Q}\in\mathbb{R}^{T_q\times{d_c}}</script></td><td>长度为<script type="math/tex">T_q</script>的查询集样本上下文向量表示</td></tr><tr><td><script type="math/tex">\mathrm{S}_k\in\mathbb{R}^{T_k\times{d_c}};k=1,...,K</script></td><td>长度为<script type="math/tex">T_k</script>的支持集样本上下文向量表示</td></tr></tbody></table></div><p>小写粗体字母为列向量 </p><h1 id="Instance-Encoder-样本编码器"><a href="#Instance-Encoder-样本编码器" class="headerlink" title="Instance Encoder 样本编码器"></a>Instance Encoder 样本编码器</h1><p>给定样本<script type="math/tex">x=\{w_1,...,w_T\}</script>，可以使用嵌入层（Embedding Layer）将每个单词<script type="math/tex">w_t</script>映射到连续输入嵌入（continuous input embeddings），使<script type="math/tex">\mathrm{w}_t\in\mathbb{R}^{d_w}</script>以表示单词的语义及句法含义。这些词嵌入由GloVe预训练。</p><p>对于每个单词<script type="math/tex">w_t</script>，将单词与实体的相对距离嵌入到两个<script type="math/tex">d_p</script>的向量并将其拼接得到位置嵌入<script type="math/tex">\mathrm{p}_t\in\mathbb{R}^{2\times d_p}</script>.</p><span id="more"></span><p>最终的每个词的输入嵌入由其词嵌入与位置嵌入拼接而得。样本经过嵌入层处理，可得到以下形式的嵌入序列：</p><script type="math/tex; mode=display">\{\mathrm{e_1}...,\mathrm{e_n}\}=\{[\mathrm{w_1};\mathrm{p_1}],...,[\mathrm{w_n};\mathrm{p_n}]\},\mathrm{e_i}\in\mathbb{R}^{d_i},d_i=d_w+d_p\times2.</script><p>编码层（Encoding Layer）使用CNN对输入嵌入（input embeddings）进行编码。对于卷积核窗口大小为<script type="math/tex">m</script>，维度为<script type="math/tex">d_h</script>的CNN，有：</p><script type="math/tex; mode=display">\mathrm{h_i}=CNN(\mathrm{e}_{i-\frac{m-1}{2}},...,\mathrm{e}_{i+\frac{m-1}{2}})</script><p>对隐藏层嵌入进行最大池化操作，得到最终的样本嵌入<script type="math/tex">\mathrm{x}</script>：</p><script type="math/tex; mode=display">[\mathrm{W}]j=max\{[\mathrm{h_1}]_j,...,[\mathrm{h_n}]_j\}</script><p>其中<script type="math/tex">[\cdot]_j</script>是向量的第<script type="math/tex">j</script>个值。</p><p>将以上的样本编码（instance encoding）操作定义为：</p><script type="math/tex; mode=display">\mathrm{W}=f_\phi(x)</script><p>其中<script type="math/tex">\phi</script>是样本编码器的可学习参数。</p><h1 id="prototypical-network-原型网络"><a href="#prototypical-network-原型网络" class="headerlink" title="prototypical network 原型网络"></a>prototypical network 原型网络</h1><p>原型网络的主要思想是使用一个称作原型的向量来表示每个关系。最简单的原型计算方法是分别对支持集中每种关系的所有样本嵌入取平均值：</p><script type="math/tex; mode=display">C^i=\frac{1}{K}\sum_{k=1}^{K}{\mathrm{S}_k^i},</script><p>其中<script type="math/tex">C_i</script>是关系<script type="math/tex">r_i</script>的原型，<script type="math/tex">\mathrm{S}_k^i</script>是支持集<script type="math/tex">\mathcal{S}</script>中关系为<script type="math/tex">r_i</script>的一个样本的样本嵌入，<script type="math/tex">K</script>是支持集<script type="math/tex">S</script>中关系为<script type="math/tex">r_i</script>的样本数量。 </p><p>在简单原型网络中取平均值的方式下，所有的样本被视为具有相同的重要程度。可以使用<strong>混合注意力机制</strong>代替取平均值，为更重要的样本分配更高的权重。</p><p>对于一个查询集样本<script type="math/tex">q</script>，通过下式计算其属于<script type="math/tex">\mathcal{R}</script>中关系的概率：</p><script type="math/tex; mode=display">p_{\phi}(y=r_i|q)=\frac{exp(-d(f_{\phi}(q),C_i))}{\sum_{j=1}^{|\mathcal{R}|}exp(-d(f_{\phi}(q),C_j))},</script><p>其中<script type="math/tex">d(\cdot,\cdot)</script>是用于计算两个向量间距离的度量函数。</p><h1 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h1><p>在Prototypical Network中，每个类别的原型由支持集中该类别所有样本的向量表示取均值而得。然而，在实际中每个类别的含义很丰富，在不同的样本中含义存在一定差别，直接对向量表示取平均值获得的原型不够准确。</p><p>注意力机制可以使模型更关注某些样本或样本的某些特征。</p><h2 id="Context-attention"><a href="#Context-attention" class="headerlink" title="Context attention"></a>Context attention</h2><p>基于支持集中不同样本重要性不同的事实，提出上下文注意力机制，向与原型更相关的样本分配更高的权重。计算样本向量表示<script type="math/tex">\mathbf{S}</script>之间的矩阵乘积再除以<script type="math/tex">\sqrt{d_w}</script>以表示<script type="math/tex">\mathbf{S}</script>中样本之间的相关性，再对其使用<script type="math/tex">softmax</script>获得每个样本的权重。最终的<script type="math/tex">\mathbf{S}_{new}</script>由权重乘以样本向量表示获得：</p><script type="math/tex; mode=display">\mathbf{S}_{new}=CATT(\mathbf{S})=softmax(\frac{ss^T}{\sqrt{d_w}})\mathbf{S}</script><h2 id="Hybrid-Attention"><a href="#Hybrid-Attention" class="headerlink" title="Hybrid Attention"></a>Hybrid Attention</h2><p>原文 <em>Hybrid Attention-Based Prototypical Networks for Noisy Few-Shot Relation Classification</em></p><p>文中混合注意力包括两个模块：样本级别注意力模块从支持集中选择包含更多信息的样本；特征级别注意力模块在距离度量函数中强调更重要的维度。</p><h3 id="Instance-level-Attention"><a href="#Instance-level-Attention" class="headerlink" title="Instance-level Attention"></a>Instance-level Attention</h3><p>原始的原型网络使用样本向量（vector of the instances）的平均值作为关系原型。在小样本的条件下，支持集样本数量有限，若一个关系中某个样本的向量表示（representation）与其他样本相差很大，则会使对应的原型产生很大偏差。同时，朴素的（vanilla）原型网络在从支持集提取特征时，从未见过具体的查询样本。因此，朴素（vanilla）的模型会提取到一些对识别查询集样本没有帮助的特征。</p><p><strong>这些现象</strong>会导致模型在对查询集样本进行分类时计算出不准确的原型。为了改进原型网络，文中提出了样本级别注意力模块，使模型更关注与查询集相关的样本并缓解噪声。文中提出对于给定的查询集样本，每个支持集样本的作用不是完全相同的，对样本向量表示赋予一个权重<script type="math/tex">\alpha_j</script>，则原型的计算方式改变为：</p><script type="math/tex; mode=display">C^i=\sum_{k=1}^K{\alpha_k\mathrm{S}_k^i}.</script><p>其中<script type="math/tex">\alpha_k</script>计算方式如下：</p><script type="math/tex; mode=display">\alpha_k=\frac{\mathrm{exp}(e_j)}{\sum_{k=1}^{K}\mathrm{exp}(e_k)}</script><script type="math/tex; mode=display">e_j=\mathrm{sum}\{\sigma(g(\mathrm{S}_k^i){\odot}g(\mathrm{Q}))\}</script><p>其中<script type="math/tex">g(\cdot)</script>是线性层，<script type="math/tex">\odot</script>是逐元素相乘，<script type="math/tex">\sigma(\cdot)</script>是激活函数，<script type="math/tex">\mathrm{sum}\{\cdot\}</script>是对向量中所有元素取和，文中使用tanh作为<script type="math/tex">\sigma(\cdot)</script>以产生<script type="math/tex">[-1,1]</script>的结果。</p><p>通过样本级别的注意力，与查询集样本具有相似特征的样本会获得更高的权重，最终的原型也会与这些样本更接近。直觉上，属于同种关系的样本也会存在很大的不同，甚至某些样本存在标记错误。查询集样本可能只与支持集中部分样本接近。对不同样本赋予不同权重后，得到的原型相比于原始的向量平均值会更加“典型”。</p><h3 id="Feature-level-Attention"><a href="#Feature-level-Attention" class="headerlink" title="Feature-level Attention"></a>Feature-level Attention</h3><p><em>Prototypical networks for few-shot learning</em>提出距离度量函数的选择对原型网络的效果有很大影响。原始的原型网络选择简单的欧几里德距离作为距离度量函数。由于在支持集中只有少量样本，特征提取会受到数据稀疏的影响（data sparsity）。因此，特征空间中的某些维度在识别特定关系时，更具有决定性作用。文中提出了特征级别的注意力，能够缓解特征稀疏（feature sparsity）的问题，更好的测量空间距离。</p><p>特征级别注意力在测量空间距离时，会更注意具有更强决定性的维度，采用以下距离度量函数代替平凡的欧几里德距离，</p><script type="math/tex; mode=display">d(\mathrm{s_1, s_2})=\mathrm{z}_i\cdot(\mathrm{s_1-s_2})^2</script><p>其中<script type="math/tex">\mathrm{z}_i</script>是由特征级别注意力提取器计算得到的对关系<script type="math/tex">r_i</script>的分数向量。特征级别注意力提取器的结构见下图（<strong>注意padding和stride</strong>）：</p><div align=center> <img src="/2020/11/09/protonet-with-attention/feature-level-attention.png" class=""> </div><p>该提取器基于每个关系的句向量表示计算出特征每个维度的线性可分程度。特征的某个维度越有用，该维度的分数就越高。将注意力分数乘上平方差距离，改变后的距离度量函数将更适用与度量给定关系与支持集样本的距离。</p><h2 id="Local-Matching-and-Aggregation"><a href="#Local-Matching-and-Aggregation" class="headerlink" title="Local Matching and Aggregation"></a>Local Matching and Aggregation</h2><p>为了更好的获取<script type="math/tex">\mathrm{Q}</script>与<script type="math/tex">\{\mathrm{S}_k;k=1,...,\mathrm{K}\}</script>之间的匹配信息，首先将<script type="math/tex">K</script>个支持集样本的向量表示拼接为一个矩阵，如下：</p><script type="math/tex; mode=display">\mathrm{C}=\textrm{concat}(\{\mathrm{S}_k\}_{k=1}^{K})</script><p>其中 <script type="math/tex">\mathrm{C}\in\mathbb{R}^{T_s{\times}d_c}</script>，<script type="math/tex">T_s=\sum_{k=1}^K{T_k}</script> ， <script type="math/tex">\mathrm{Q}</script> 与 <script type="math/tex">\mathrm{C}</script> 匹配后的向量表示 <script type="math/tex">\widetilde{\mathrm{Q}}</script> 与 <script type="math/tex">\widetilde{\mathrm{C}}</script> 计算方式如下：</p><script type="math/tex; mode=display">\alpha_{mn}=\mathrm{q}_m^\top\mathrm{c}_n</script><script type="math/tex; mode=display">\widetilde{\mathbf{q}}_m=\sum_{n=1}^{T_s}\frac{\mathrm{exp}(\alpha_{mn})}{\sum_{n'=1}^{T_s}\mathrm{exp}(\alpha_{mn'})}\mathbf{c}_n, m\in\{1,...,T_q\}</script><script type="math/tex; mode=display">\widetilde{\mathbf{c}}_n=\sum_{m=1}^{T_q}\frac{\mathrm{exp}(\alpha_{mn})}{\sum_{m'=1}^{T_q}\mathrm{exp}(\alpha_{m'n})}\mathbf{q}_m, n\in\{1,...,T_s\}</script><p>然后，使用一个ReLU激活层将原始的向量表示与匹配后的向量表示进行融合：</p><script type="math/tex; mode=display">\bar{\mathbf{Q}}=\mathrm{ReLU}([\mathbf{Q};\mathbf{\widetilde{Q}};|\mathbf{Q}-\mathbf{\widetilde{Q}}|;\mathbf{Q}\odot\mathbf{\widetilde{Q}}]\mathbf{W}_1),</script><script type="math/tex; mode=display">\bar{\mathbf{C}}=\mathrm{ReLU}([\mathbf{C};\mathbf{\widetilde{C}};|\mathbf{C}-\mathbf{\widetilde{C}}|;\mathbf{C}\odot\mathbf{\widetilde{C}}]\mathbf{W}_1),</script><p>其中<script type="math/tex">\odot</script>是逐元素相乘，<script type="math/tex">\mathbf{W}_1\in\mathbb{R}^{4{d_c}\times{d_h}}</script>是该层用于降维的线性映射的权重。<script type="math/tex">\bar{\mathbf{C}}</script>将与<script type="math/tex">K</script>个支持集样本对应的分为<script type="math/tex">K</script>个向量表示<script type="math/tex">\{\bar{\mathbf{S}}_k\}_{k=1}^{K}</script>，其中<script type="math/tex">\bar{\mathbf{S}}_k\in\mathbb{R}^{T_k\times{d_h}}</script>。所有的<script type="math/tex">\bar{\mathbf{S}}_k</script>与<script type="math/tex">\bar{\mathbf{Q}}</script>再输入到隐藏层单元数为<script type="math/tex">d_h</script>的单层双向LSTM中，拼接两个方向的输出得到最终的本地匹配结果为：<script type="math/tex">\hat{\mathbf{S}}_k\in\mathbb{R}^{T_k\times{2d_h}}</script>和<script type="math/tex">\hat{\mathbf{Q}}\in\mathbb{R}^{T_q\times{2d_h}}</script>。</p><p>本地聚合的目标是本地匹配的结果<script type="math/tex">\hat{\mathbf{S}}_k,\hat{\mathbf{Q}}</script>转换为单个向量。本文使用最大池化与平均池化，再将其结果拼接，得到单个向量<script type="math/tex">\hat{\mathbf{s}}_k</script>或<script type="math/tex">\hat{\mathbf{q}}</script>,计算过程如下：</p><script type="math/tex; mode=display">\hat{\mathbf{s}}_k=[\mathrm{max}(\hat{\mathbf{S}}_k);\mathrm{ave}(\hat{\mathbf{S}}_k)],\forall k\in\{1,...,K\},</script><script type="math/tex; mode=display">\hat{\mathbf{q}}=[\mathrm{max}(\hat{\mathbf{Q}});\mathrm{ave}(\hat{\mathbf{Q}})]</script><p>其中<script type="math/tex">\hat{\mathbf{s}}_k,\hat{\mathbf{q}}\in\mathbb{R}^{4d_h}</script>。</p><h2 id="Instance-Matching-and-Aggregation"><a href="#Instance-Matching-and-Aggregation" class="headerlink" title="Instance Matching and Aggregation"></a>Instance Matching and Aggregation</h2><p>与经典的原型网络类似，本文的方法使用支持集某个类别所有样本的向量表示<script type="math/tex">\{\hat{\mathbf{s}}_k\}_{k=1}^{K}</script>计算该类别的原型<script type="math/tex">\hat{\mathbf{s}}</script>，使用注意力机制聚合样本级别特征表示，每个样本的权重由<script type="math/tex">\hat{\mathbf{s}}_k</script>与<script type="math/tex">\hat{\mathbf{q}}</script>的匹配分数导出，匹配函数如下：</p><script type="math/tex; mode=display">\beta_k=\mathbf{v}^{\top}(\mathrm{ReLU}(\mathbf{W}_2[\hat{\mathbf{s}}_k;\hat{\mathbf{q}}]))</script><p>其中<script type="math/tex">\mathbf{W}_2\in\mathbb{R}^{d_h\times8d_h}</script>，<script type="math/tex">\mathbf{v}\in\mathbb{R}^{d_h}</script>，<script type="math/tex">\beta_k</script>代表查询集样本<script type="math/tex">q</script>与支持集样本<script type="math/tex">\mathbf{s}_k</script>的匹配程度。然后，所有的<script type="math/tex">\{\hat{\mathbf{s}}_k\}_{k=1}^K</script>被聚合为一个向量<script type="math/tex">\hat{\mathbf{s}}</script>:</p><script type="math/tex; mode=display">\hat{\mathbf{s}}=\sum_{k=1}^K\frac{\mathrm{exp}(\beta_k)}{\sum_{k'=1}^K\mathrm{exp}(\beta'_k)}\hat{\mathbf{s}}_k</script><p>$\hat{\mathbf{s}}$就是类别的原型。</p><h2 id="Class-Matching"><a href="#Class-Matching" class="headerlink" title="Class Matching"></a>Class Matching</h2><p>类别的原型<script type="math/tex">\hat{\mathbf{s}}</script>以及查询集样本<script type="math/tex">\hat{\mathbf{q}}</script>确定之后，类别匹配函数<script type="math/tex">f(\{s_k\}_{k=1}^K,q)</script>定义如下：</p><script type="math/tex; mode=display">f(\{s_k\}_{k=1}^K,q)=\mathbf{v}^\top(\mathrm{ReLU}(\mathbf{W}_2)[\hat{\mathbf{s}};\hat{\mathbf{q}}])</script><p>在本文的实验中，共享权重<script type="math/tex">\mathbf{W}_2</script>与<script type="math/tex">\mathbf{v}</script>取得了最好的效果。</p><h2 id="Joint-Training-with-Inconsistency-Measurement"><a href="#Joint-Training-with-Inconsistency-Measurement" class="headerlink" title="Joint Training with Inconsistency Measurement"></a>Joint Training with Inconsistency Measurement</h2><p>若一个类别中的支持集样本向量表示相差过大，得到的原型将难以捕捉所有支持集样本的共同特征。本文计算所有支持集样本与其对应类别原型的不一致程度，并将其加入损失函数进行训练。</p><p>[用词] prototype, vector</p>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>few-shot</tag>
      
      <tag>prototypical network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Meta Networks ()</title>
    <link href="/2020/10/16/metanets/"/>
    <url>/2020/10/16/metanets/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>神经网络已成功应用于带有大量标记数据的应用中。 但是，在训练数据较少的情况下快速归纳新概念，同时又要保留先前学习的性能的任务，仍然对神经网络模型提出了重大挑战。 在本文的工作中，我们介绍了一种新颖的元学习方法Meta Networks（MetaNet），该方法可跨任务学习元级别知识，并通过快速参数化来转变其<strong>归纳偏置</strong>，以实现快速归纳。 在Omniglot和Mini-ImageNet基准测试中进行评估时，我们的MetaNet模型可达到接近人类水平的性能，并且相对与基线方法提升了高达6%的准确率。 我们解释了与泛化和持续学习有关的MetaNet的几个重要的特性。</p><p><strong>归纳偏置</strong>：在机器学习中，很多学习算法经常会对学习的问题做一些假设，这些假设就称为归纳偏置(Inductive Bias)。参考<a href="https://www.zhihu.com/question/264264203">知乎问题</a></p><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>当有大量标记数据可用于训练时，深度神经网络已在多个应用领域中取得了巨大成功。然而，大多数学习任务的前提是能够获得大量的训练数据。此外，标准的深度神经网络缺乏在不忘记或破坏先前学习的模式的情况下，连续不断地学习或逐步学习新概念的能力。 相反，人类可以从相同概念的一些示例中快速学习和概括。 人类也非常擅长增量（即连续）学习。 这些能力主要是通过大脑的元学习（即学习学习）过程来解释的（Harlow，1949）。</p><p>先前有关元学习的工作将问题定义为两个层次的学习：对跨任务执行元级模型的缓慢学习，以及对在每个任务中起作用的基础级模型的快速学习（Mitchell at el., 1993;  Vilalta ＆ Drissi, 2002）。元级学习器的目标是获得不同任务之间通用的一般知识。然后可以将知识转移到基础级学习器，以在单个任务的上下文中提供泛化能力。基本模型和元模型可以构造在单个学习器中（Schmidhuber, 1987）或在分别在单独的学习器中（Bengio等，1990； Hochreiter等，2001）。</p><p>在本文的工作中，我们介绍了一种称为MetaNet (Meta Networks) 的元学习模型，该模型能够让神经网络在学习单个样本时进行新任务或概念的归纳。MetaNet的总体结构如图1所示。MetaNet由两个主要的学习组件组成，即基础学习器和元学习器，并配备了一个外部记忆单元。学习发生在两个层次的空间（即元空间和任务空间）中。基础学习器在输入任务空间中执行，而元学习器在与任务无关的元空间中运行。通过在抽象元空间中进行操作，元学习器支持<strong>持续学习</strong>并在不同任务之间实现元知识获取。 为此，基础学习器首先分析输入任务，以较高阶元信息的形式向元学习器提供反馈，以解释其在当前任务空间中的状态。基于元信息，元学习器可以快速设定自身和基础学习器的参数，以便MetaNet模型可以识别输入任务中的新概念。 具体来说，MetaNet的训练权重在不同的时间尺度上更新：通过学习算法（如REINFORCE）更新标准慢速权重；在每个任务范围内更新任务级快速权重；对于特定的输入示例更新示例级快速权重。 此外，MetaNet还配备了外部存储器以实现快速学习和归纳。</p><p><strong>持续学习</strong> <strong>(continual learning/ life-long learning)</strong> ：我们人类有能够将一个任务的知识用到另一个任务上的能力，学习后一个任务时也不会忘记如何做前一个任务，这种能力叫<strong>持续学习</strong> <strong>(continual learning/ life-long learning)</strong> 。</p><div align=center> <img src="/2020/10/16/metanets/fig1.png" class=""> </div><center><font size=2.5>Figure 1. Overall architecture of Meta Networks.</font></center><p>在MetaNet框架下，定义从学习器获得的元信息类型非常重要， 我们将损失梯度用作元信息（元信息的其他表示形式也适用）。MetaNet具有两种类型的损失函数：用于评判表示学习器的表示（即嵌入）损失，和用于输入任务目标任务的损失。</p><p>我们在几种不同的设置下，广泛研究了MetaNet在one-shot监督学习（SL）问题上的性能和特点。 我们提出的方法不仅改进了标准基准测试的最新结果，而且还显示了一些与泛化和持续学习有关的有趣特性。</p><h1 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h1><p>我们的工作与多个不同的以快速学习和泛化为目标的神经网络模型架构研究有关。快速学习和泛化指的是one-shot学习：学习器需要处理多个多分类任务，在每个任务中，每个类只有一个或几个标记的样本。此问题中的主要挑战是，各个任务中的类别与概念会有所不同。目前有很多生成模型和度量学习方法被用于解决one-shot学习问题。概率编程方法取得了一个显着的成功（Lake等，2015），他们使用了组合笔画以产生不同字母字符的特定知识。Koch（2015）使用Siamese Networks进行了one-shot分类。最近，Vinyals等（2016）统一了one-shot学习器的训练和测试流程，并开发了一种端到端的微分最近邻方法用于one-shot学习。 Santoro等（2016）提出了一种基于记忆的方法和经过训练的Neural Turing Machines（Graves等人，2014）来进行one-shot学习，但这项工作中的元学习器和one-shot学习器不是明确独立的。 Santoro等人使用的训练流程（2016）改进了Hochreiter等人的工作（2001），他们使用LSTM作为元级模型。最近，（Ravi＆Larochell，2017）提出了一种基于LSTM的one-shot优化器，通过考虑基础学习器的损失、梯度和参数，对元优化器进行训练，并更新one-shot分类器的参数。</p><p>一项相关工作的重点是构建元优化器（Hochreiter等，2001；Maclaurin等，2015；Andrychowicz等，2016；Li＆Malik，2017）。该方向的主要兴趣是在元学习框架内训练优化算法，因此这些工作主要集中在具有大型数据集的任务上。与之相反，由于缺少大型数据集，我们的实验设置强调了优化具有大量参数的神经网络以从少量样本中归纳出新概念的挑战性。我们的工作提出了一种巧妙的的利用元信息的快速参数化方法。通过跟踪先前工作的成功（Mitchell等，1993; Younger等，1999; Andrychowicz等，2016; Ravi＆Larochell，2017），我们研究了表现在神经网络损失梯度中的元信息。快速权重和利用一个神经网络为另一个神经网络生成参数已经分别有了单独的研究。Hinton＆Plaut（1987）建议使用快速权重进行快速学习。 Ba等（2016）最近使用快速权重代替了软注意力机制。快速权重也已用于实现循环网络（Schmidhuber，1992； 1993a）和自指网络（Schmidhuber，1987； 1993b）。突触在许多不同的时间尺度上都有动态，这一事实很好地启发了这些快速权重的使用（Greengard，2001）。</p><p>最后，我们注意到，配备有外部存储单元的MetaNet可以看作是记忆增强神经网络（MANN）。从小的程序设计问题（Graves等人，2014）到大规模语言任务（Weston等人，2015; Sukhbaatar等人，2015; Munkhdalai＆Yu，2017），MANN在一系列任务上都显示出令人鼓舞的结果 。</p><h1 id="3-Meta-Networks"><a href="#3-Meta-Networks" class="headerlink" title="3. Meta Networks"></a>3. Meta Networks</h1><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><div class="table-container"><table><thead><tr><th>项目</th><th>符号</th></tr></thead><tbody><tr><td>Support set</td><td><script type="math/tex">\{x'_i, y'_i\}^N_{i=1}</script></td></tr><tr><td>Train set</td><td><script type="math/tex">\{x_i, y_i\}^L_{i=1}</script></td></tr><tr><td>Base learner</td><td><script type="math/tex">b</script></td></tr><tr><td>Dynamic representation learning function</td><td><script type="math/tex">u</script></td></tr><tr><td>Fast weight generation functions</td><td><script type="math/tex">m</script> and <script type="math/tex">d</script></td></tr><tr><td>Slow weights</td><td><script type="math/tex">\theta=\{W, Q, Z, G\}</script></td></tr></tbody></table></div><p>MetaNet通过处理更高阶的元信息来学习快速参数化基础神经网络，以进行快速概括，从而产生一个灵活的AI模型，该模型可以适应输入输出分布不同的一系列任务。 该模型包括两个主要的学习模块（图1）。 元学习器负责通过跨任务进行操作来生成快速权重，而基础学习器则每个任务中训练以优化任务目标。 生成的快速权重被集成到基础学习器和元学习器中，以改变学习器的归纳偏置。 我们提出了一种新颖的层增强方法，以将标准慢权重与任务或示例特定的快速权重集成到神经网络中。</p><p>我们训练MetaNet的流程基于Vinyals等（2016）提出的方法。 我们首先构造一系列任务，每个任务都包含一个支持集和一个训练集。 对于相同任务的支持集和训练集，类标签是一致的，但是在不同任务之间会有所不同。 MetaNet的训练包括三个主要过程：<em>元信息的获取，快速权重的生成，慢速权重的优化</em>。由基础和元学习器共同执行。 算法1描述了MetaNet的训练流程。</p><div align=center> <img src="/2020/10/16/metanets/alg1.png" class=""> </div><p>为了在one-shot SL中测试模型，我们从具有未知类别的测试数据集中采样了另一组任务。 然后，部署模型基于其支持集对测试样本进行分类。 我们假设在训练和测试期间我们都具有支持集样本的标签。 注意在one-shot学习的设置中，支持集每个类别仅包含一个示例，因此容易获得。</p><h2 id="3-1-Meta-Learner"><a href="#3-1-Meta-Learner" class="headerlink" title="3.1 Meta Learner"></a>3.1 Meta Learner</h2><p>元学习器包括动态表示学习函数<script type="math/tex">u</script>和快速权重生成函数<script type="math/tex">m</script>和<script type="math/tex">d</script>。 函数<script type="math/tex">u</script>具有表示学习目标，并通过使用任务级快速权重在每个任务空间中构造输入的嵌入。 权重生成函数<script type="math/tex">m</script>和<script type="math/tex">d</script>负责处理元信息，并生成示例和任务级快速权重。</p><p>更具体地说，函数<script type="math/tex">m</script>学习从从基础学习器<script type="math/tex">b</script>导出的损失梯度<script type="math/tex">\{\bigtriangledown_i\}^N_{i=1}</script>到快速权重<script type="math/tex">\{W_i^*\}^N_{i=1}</script>的映射：</p><p><script type="math/tex">W_i^*=m(Z, \bigtriangledown_i)</script>            (1)</p><p>其中<script type="math/tex">m</script>是参数为<script type="math/tex">Z</script>的神经网络。然后将快速权重存储在M 记忆单元<script type="math/tex">M=\{W_i^*\}^N_{i=1}</script>中。记忆单元<script type="math/tex">M</script>使用由动态表示学习函数<script type="math/tex">u</script>获得的对支持集样本<script type="math/tex">\{x'_i\}^N_{i=1}</script>的任务相关嵌入<script type="math/tex">R=\{r'_i\}^N_{i=1}</script>进行索引。</p><p>表示学习函数<script type="math/tex">u</script>是由慢速权重<script type="math/tex">Q</script>和任务级快速权重<script type="math/tex">Q^*</script>参数化的神经网络。 它使用表示损失<script type="math/tex">loss_{emb}</script>来捕获表示学习目标并获得梯度作为元信息。 我们基于每个任务生成快速权重<script type="math/tex">Q^*</script>，如下所示：</p><p><script type="math/tex">\mathcal{L}_i=loss_{emb}(u(Q,x'_i),y'_i)</script>            (2)</p><p><script type="math/tex">\bigtriangledown_i=\bigtriangledown_Q\mathcal{L}_i</script>            (3)</p><p><script type="math/tex">Q^*=d(G,\{\bigtriangledown\}^T_{i=1})</script>            (4)</p><p>其中<script type="math/tex">d</script>表示由<script type="math/tex">G</script>参数化的神经网络，它接受大小可变的输入。 首先，我们从支持集中采样<script type="math/tex">T</script>个样本<script type="math/tex">(T{\leq}N)\{x'_i, y'_i\}^T_{i=1}</script>，并获得其损失梯度作为元信息。 然后，<script type="math/tex">d</script>观察与每个采样的样本对应的梯度，并总结为任务特定的参数。我们使用LSTM作为<script type="math/tex">d</script>，但<script type="math/tex">d</script>的输入顺序是无关紧要的。我们也尝试求梯度取总和或平均值，再使用MLP。 但是，在我们的初步实验中，我们观察到后者导致收敛性较差。</p><p>生成快速权重后，与任务相关的输入表示<script type="math/tex">\{r'_i\}^N_{i=1}</script>的计算方式为：</p><p><script type="math/tex">r'_i=u(Q,Q^*,x'_i)</script>            (5)</p><p>其中参数<script type="math/tex">Q</script>和<script type="math/tex">Q^*</script>使用3.3节介绍的层增强算法进行整合。</p><p>损失<script type="math/tex">loss_{emb}</script>无需与主任务损失<script type="math/tex">loss_{task}</script>相同，但必须能够捕获表示学习目标。在支持集中每个类别只有一个样本时，我们使用交叉熵损失。当每个类别中的样本数量大于<script type="math/tex">1</script>时，使用contrastive loss (Chopra et 等., 2005)作为<script type="math/tex">loss_{emb}</script>比较合适，因为正负样本都能被考虑到。在此情况下，我们随机选取<script type="math/tex">T</script>对样本计算其梯度，损失计算如下：</p><p><script type="math/tex">\mathcal{L}_i=loss_{emb}(u(Q,x'_{1,i}),u(Q,x'_{2,i}),l_i)</script>            (6)</p><p>其中<script type="math/tex">l_i</script>​为辅助标签：</p><p><script type="math/tex">l_i=\left\{ \begin{array}{ll}1, & \textrm{if y'_{1,i}=y'_{2,i}}\\0, & \textrm{otherwise}\end{array} \right.</script>            （7）</p><p>在参数被存储在记忆单元<script type="math/tex">M</script>中且记忆单元索引<script type="math/tex">R</script>构造完之后，元学习器就用快速权重<script type="math/tex">W^*_i</script>对基础学习器进行参数化。 首先，它使用动态表示学习网络（即式5）将输入<script type="math/tex">x_i</script>嵌入到任务空间中，然后软注意力读取记忆单元：</p><p><script type="math/tex">a_i=attention(R, r_i)</script>            （8）</p><p><script type="math/tex">W^*_i=norm(a_i)^{\top}M</script>            （9）</p><p>其中，<script type="math/tex">attention</script>计算记忆单元索引和输入嵌入之间的相似度，我们使用余弦相似度作为<script type="math/tex">attention</script>。<script type="math/tex">norm</script>是归一化函数，我们使用的是<script type="math/tex">softmax</script>。</p><h2 id="3-2-Base-Learner"><a href="#3-2-Base-Learner" class="headerlink" title="3.2 Base Learner"></a>3.2 Base Learner</h2><p>基础学习器（记为<script type="math/tex">b</script>）是以任务损失<script type="math/tex">loss_{task}</script>评估主要任务目标的函数或神经网络。 但与标准神经网络不同，<script type="math/tex">b</script>由慢速权重<script type="math/tex">W</script>和样本级快速权重<script type="math/tex">W^*</script>参数化。慢速权重在训练期间通过学习算法进行更新，而快速权重由元学习器为每个输入样本生成。</p><p>基础学习器使用通过从支持集获得的元信息的表示，为元学习器提供有关新输入任务的反馈。 元信息以损失梯度信息的形式从基础学习者中得出：</p><p><script type="math/tex">\mathcal{L}_i=loss_{task}(b(W,x'_i),y'_i)</script>            (10)</p><p><script type="math/tex">\bigtriangledown_i=\bigtriangledown_W\mathcal{L}_i</script>            (11)</p><p>其中<script type="math/tex">\mathcal{L}_i</script>是支持集样本<script type="math/tex">\{x'_i, y'_i\}^N_{i=1}</script>的损失。<script type="math/tex">N</script>是任务中支持集样本的数量（通常在one-shot设置中，每个类别有一个样本）。<script type="math/tex">\bigtriangledown_i</script>是相对于参数<script type="math/tex">W</script>的损失梯度，我们将其作为元信息。 注意，损失函数<script type="math/tex">loss_{task}</script>是通用的，可以采用任何形式，例如强化学习中的累积奖励。 对于one-shot分类，我们使用交叉熵损失。 元学习器接受梯度信息<script type="math/tex">\bigtriangledown_i</script>并生成快速参数<script type="math/tex">W^*</script>，见式(1)。</p><p>定义了输入<script type="math/tex">x_i</script>的快速权重为<script type="math/tex">W^*_i</script>，基础学习器将执行one-shot分类为：</p><p><script type="math/tex">P(\hat{y}_i|x_i, W_i,W^*_i)=b(W,W^*_i,x'_i)</script>            (12)</p><p>其中<script type="math/tex">\hat{y}_i</script>是预测输出，而<script type="math/tex">\{x_i\}^L_{i=1}</script>是从当前任务训练集<script type="math/tex">\{x_i,y_i\}^L_{i=1}</script>取出的输入。 或者，基础学习器可以将动态表示学习网络生成的任务特定表示<script type="math/tex">\{r_i\}^L_{i=1}</script>作为输入，从而有效地减少MetaNet参数的数量并利用共享表示。 在这种情况下，基础学习器被限制在由<script type="math/tex">u</script>构成的动态任务空间中操作，而不是从原始输入<script type="math/tex">\{x_i\}^L_{i=1}</script>构建新的表示。</p><p>在训练过程中，给定输出标签<script type="math/tex">\{y_i\}^L_{i=1}</script>，我们最小化one-shot SL的交叉熵损失。 MetaNet的训练参数由慢速权重<script type="math/tex">W</script>和<script type="math/tex">Q</script>以及元权重<script type="math/tex">Z</script>和<script type="math/tex">G</script>组成（即<script type="math/tex">\theta=\{W,Q,Z,G\}</script>），并通过训练算法（例如反向传播）共同更新，以最小化任务损失<script type="math/tex">loss_{task}</script>式(12)。</p><p>以类似的方式，如式(2)~(4)中所定义，我们还可以使用任务级快速权重对基础学习者进行参数化。 在第4节，我们进行了针对MetaNet不同版本的消融实验。</p><h2 id="3-3-Layer-Augmentation"><a href="#3-3-Layer-Augmentation" class="headerlink" title="3.3 Layer Augmentation"></a>3.3 Layer Augmentation</h2><p>基础学习器中的慢速权重层由其相应的快速权重进行拓展，以实现快速概括。 图2显示了应用于MLP的层增强方法的示例。增强层的输入首先通过慢速权重和快速权重进行转换，再通过非线性（即ReLU）激活，从而得到两个单独的激活向量 。 最后，激活向量进行逐元素的向量相加。 对于最后的softmax层，我们首先汇总两个转换后的输入，然后针对分类输出进行归一化。</p><p>直观地，层增强神经网络中的快速权重和慢速权重可以看作是在两个不同的数值域中运行的特征检测器。 非线性的应用将它们映射到相同的域，在使用ReLU的情况下，该域为<script type="math/tex">[0,\infty]</script>，从而激活值可以聚合并进行下一步处理。 我们这里的聚合函数是逐元素求和。</p><p>尽管可以仅使用快速权重来定义基础学习器，但在我们的初步实验中，我们发现慢速和快速权重与层增强方法的集成对于MetaNet模型的收敛至关重要。一个仅依靠快速权重的基本精简者的MetaNet模型未能收敛，并且据报道，该模型的最佳性能与为每个输入分配相同标签的恒定分类器的性能相同。</p>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>few-shot learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>matplotlib绘制热力图动画</title>
    <link href="/2020/10/07/hotmap-animation/"/>
    <url>/2020/10/07/hotmap-animation/</url>
    
    <content type="html"><![CDATA[<p>使用python的matplotlib库绘制热力图动画</p><span id="more"></span><h1 id="绘制热力图"><a href="#绘制热力图" class="headerlink" title="绘制热力图"></a>绘制热力图</h1><p>使用<code>matplotlib.pyplot.imshow()</code>方法，参考<a href="https://www.zhihu.com/question/47456526/answer/317273113">https://www.zhihu.com/question/47456526/answer/317273113</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>x = np.random.rand(<span class="hljs-number">101</span>, <span class="hljs-number">101</span>)<br>fig, ax = plt.subplots()<br>img = ax.imshow(x, cmap=plt.cm.hot, origin=<span class="hljs-string">&#x27;lower&#x27;</span>)<br>plt.colorbar()<br>plt.show()<br></code></pre></td></tr></table></figure><h1 id="绘制动画"><a href="#绘制动画" class="headerlink" title="绘制动画"></a>绘制动画</h1><p>使用<code>matplotlib.animation import FuncAnimation</code>, 基本结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> matplotlib.animation <span class="hljs-keyword">import</span> FuncAnimation<br><span class="hljs-keyword">from</span> mpl_toolkits.axes_grid1 <span class="hljs-keyword">import</span> make_axes_locatable<br><br>fig, ax = plt.subplots()<br>div = make_axes_locatable(ax)<br>cax = div.append_axes(<span class="hljs-string">&#x27;right&#x27;</span>, <span class="hljs-string">&#x27;5%&#x27;</span>, <span class="hljs-string">&#x27;5%&#x27;</span>)<br><br>num_frames = <span class="hljs-number">50</span><br>row, col = <span class="hljs-number">101</span>, <span class="hljs-number">101</span><br>data = np.random.rand(num_frames, row, col)<br>img = ax.imshow(np.zeros((row, col)), cmap=plt.cm.hot, vmin=<span class="hljs-number">0</span>, vmax=<span class="hljs-number">1.0</span>, origin=<span class="hljs-string">&#x27;lower&#x27;</span>)<br>cbr = fig.colorbar(img, cax=cax)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">i</span>):</span><br>    X = data[i]<br>    vmax = np.<span class="hljs-built_in">max</span>(X)<br>    vmin = np.<span class="hljs-built_in">min</span>(X)<br>    img.set_data(X)<br>    img.set_clim(vmin, vmax)<br><br>ani = FuncAnimation(fig, update, frames=num_frames)<br>plt.show()<br><br></code></pre></td></tr></table></figure><p><code>FuncAnimation</code>的参数<code>update</code>绘制每一帧的图像，参数<code>frames</code>用于产生每次调用<code>update</code>的参数。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>matplotlib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python</title>
    <link href="/2020/09/28/pytorch-usage/"/>
    <url>/2020/09/28/pytorch-usage/</url>
    
    <content type="html"><![CDATA[<p>python常见库</p><span id="more"></span><h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">chdir(path)<br>    Change the current working directory to the specified path.<br>    path may always be specified <span class="hljs-keyword">as</span> a string.<br></code></pre></td></tr></table></figure><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">sample(population, k) method of random.Random instance<br>    Chooses k unique random elements from a population sequence or set.<br>    从population随机选取k个不同的元素，以list返回<br></code></pre></td></tr></table></figure><h2 id="iter"><a href="#iter" class="headerlink" title="iter"></a>iter</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">iter</span>(...)<br>    iter(iterable) -&gt; iterator<br>    iter(callable, sentinel) -&gt; iterator<br>    <br>    Get an iterator <span class="hljs-keyword">from</span> an <span class="hljs-built_in">object</span>.  In the first form, the argument must<br>    supply its own iterator, <span class="hljs-keyword">or</span> be a sequence.<br>    In the second form, the <span class="hljs-built_in">callable</span> <span class="hljs-keyword">is</span> called until it returns the sentinel.<br></code></pre></td></tr></table></figure><h2 id="next"><a href="#next" class="headerlink" title="next"></a>next</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">next</span>(...)<br>    <span class="hljs-built_in">next</span>(iterator[, default])<br>    <br>    Return the <span class="hljs-built_in">next</span> item <span class="hljs-keyword">from</span> the iterator. If default <span class="hljs-keyword">is</span> given <span class="hljs-keyword">and</span> the iterator<br>    <span class="hljs-keyword">is</span> exhausted, it <span class="hljs-keyword">is</span> returned instead of raising StopIteration.<br></code></pre></td></tr></table></figure><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">In: <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(*[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]))<br>Out: [(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>)]<br></code></pre></td></tr></table></figure><h1 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h1><h2 id="random-1"><a href="#random-1" class="headerlink" title="random"></a>random</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">choice(...) method of mtrand.RandomState instance<br>    choice(a, size=<span class="hljs-literal">None</span>, replace=<span class="hljs-literal">True</span>, p=<span class="hljs-literal">None</span>)<br>    <br>    Generates a random sample <span class="hljs-keyword">from</span> a given <span class="hljs-number">1</span>-D array<br>    <br>    Parameters<br>    -----------<br>    a : <span class="hljs-number">1</span>-D array-like <span class="hljs-keyword">or</span> <span class="hljs-built_in">int</span><br>        If an ndarray, a random sample <span class="hljs-keyword">is</span> generated <span class="hljs-keyword">from</span> its elements.<br>        If an <span class="hljs-built_in">int</span>, the random sample <span class="hljs-keyword">is</span> generated <span class="hljs-keyword">as</span> <span class="hljs-keyword">if</span> a were np.arange(a)<br>    size : <span class="hljs-built_in">int</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">tuple</span> of ints, optional<br>        Output shape.  If the given shape <span class="hljs-keyword">is</span>, e.g., ``(m, n, k)``, then<br>        ``m * n * k`` samples are drawn.  Default <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>, <span class="hljs-keyword">in</span> which case a<br>        single value <span class="hljs-keyword">is</span> returned.<br>    replace : boolean, optional<br>        Whether the sample <span class="hljs-keyword">is</span> <span class="hljs-keyword">with</span> <span class="hljs-keyword">or</span> without replacement<br>    p : <span class="hljs-number">1</span>-D array-like, optional<br>        The probabilities associated <span class="hljs-keyword">with</span> each entry <span class="hljs-keyword">in</span> a.<br>        If <span class="hljs-keyword">not</span> given the sample assumes a uniform distribution over <span class="hljs-built_in">all</span><br>        entries <span class="hljs-keyword">in</span> a.<br>    <br>    Returns<br>    --------<br>    samples : single item <span class="hljs-keyword">or</span> ndarray<br>        The generated random samples<br><br>    Examples<br>    ---------<br>    Generate a uniform random sample <span class="hljs-keyword">from</span> np.arange(<span class="hljs-number">5</span>) of size <span class="hljs-number">3</span> without<br>    replacement:<br>    <br>    np.random.choice(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, replace=<span class="hljs-literal">False</span>)<br>        array([<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>])<br>    <span class="hljs-comment">#This is equivalent to np.random.permutation(np.arange(5))[:3]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pytorch</tag>
      
      <tag>numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FewRel训练流程</title>
    <link href="/2020/09/27/FewRel-format/"/>
    <url>/2020/09/27/FewRel-format/</url>
    
    <content type="html"><![CDATA[<p>介绍FewRel数据集的格式，模型的训练流程、输入输出、loss定义。</p><span id="more"></span><p>FewRel数据集为json格式，用python的json包载入后，结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&#123;<span class="hljs-string">&#x27;class_id_1&#x27;</span>:[&#123;<span class="hljs-string">&#x27;tokens&#x27;</span>: [<span class="hljs-string">&#x27;word_1&#x27;</span>, ... , <span class="hljs-string">&#x27;word_n&#x27;</span>], <span class="hljs-string">&#x27;h&#x27;</span>: [<span class="hljs-string">&#x27;head_word&#x27;</span>, <span class="hljs-string">&#x27;Q1331049&#x27;</span>, [[<span class="hljs-number">16</span>]]], <span class="hljs-string">&#x27;t&#x27;</span>: [<span class="hljs-string">&#x27;tail_word&#x27;</span>, <span class="hljs-string">&#x27;Q3056359&#x27;</span>, [[<span class="hljs-number">13</span>, <span class="hljs-number">14</span>]]]&#125;, ...],<br><span class="hljs-string">&#x27;class_id_2&#x27;</span>:[&#123;&#125;, ...],<br>...&#125;<br></code></pre></td></tr></table></figure><h1 id="数据集处理"><a href="#数据集处理" class="headerlink" title="数据集处理"></a>数据集处理</h1><p><code>FewRelDataset</code>中一个样本为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">tuple(support_set, query_set, query_label)</span><br><span class="hljs-string"></span><br><span class="hljs-string">support_set: dict&#123;&#x27;word&#x27;: list[], &#x27;pos1&#x27;: list[], &#x27;pos2&#x27;: list[], &#x27;mask&#x27;: list[] &#125;</span><br><span class="hljs-string">query_set: dict&#123;&#x27;word&#x27;: list[], &#x27;pos1&#x27;: list[], &#x27;pos2&#x27;: list[], &#x27;mask&#x27;: list[] &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;word&#x27;, &#x27;pos1&#x27;, &#x27;pos2&#x27;, &#x27;mask&#x27;的list中都含有N * K个元素,</span><br><span class="hljs-string">每个元素都是torch.tensor, shape = [max_length], dtype=torch.int64, 其label与query_label对应</span><br><span class="hljs-string"></span><br><span class="hljs-string">query_label: list[int]</span><br><span class="hljs-string">[0, 0, ..., 0, 1, 1, ..., 1, 2, 2, ..., 2, ..., N - 1, N - 1, ..., N - 1]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p><code>data_loader.get_loader</code>方法返回<code>iter(data_loader)</code></p><p><code>next(data_loader)</code>得到的数据为：<code>tuple(batch_support, batch_query, batch_label)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">batch_support, batch_query: dict&#123;&#x27;word&#x27;: tensor, &#x27;pos1&#x27;: tensor, &#x27;pos2&#x27;: tensor, &#x27;mask&#x27;: tensor&#125;</span><br><span class="hljs-string">    </span><br><span class="hljs-string">torch.Size([batch_size * N * K, maxlen])</span><br><span class="hljs-string">batch_label: torch.Size([batch_size * N * K])</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python train_demo.py --test val_nyt --model proto --encoder cnn<br></code></pre></td></tr></table></figure><h2 id="指定数据集"><a href="#指定数据集" class="headerlink" title="指定数据集"></a>指定数据集</h2><div class="table-container"><table><thead><tr><th>参数</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>—train</td><td>train_wiki</td><td></td></tr><tr><td>—val</td><td>val_wiki</td><td></td></tr><tr><td>—test</td><td>test_wiki</td></tr></tbody></table></div><h2 id="任务设置"><a href="#任务设置" class="headerlink" title="任务设置"></a>任务设置</h2><div class="table-container"><table><thead><tr><th>参数</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>—trainN</td><td>10</td><td>训练时的N</td></tr><tr><td>—N</td><td>5</td><td>N-way</td></tr><tr><td>—K</td><td>5</td><td>K-shot</td></tr><tr><td>—Q</td><td>5</td><td>查询集中每个类别样本数量</td></tr></tbody></table></div><h2 id="训练设置"><a href="#训练设置" class="headerlink" title="训练设置"></a>训练设置</h2><div class="table-container"><table><thead><tr><th>参数</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>—batch_size</td><td>4</td><td></td></tr><tr><td>—train_iter</td><td>30000</td><td>训练迭代次数</td></tr><tr><td>—val_iter</td><td>1000</td><td>验证迭代次数</td></tr><tr><td>—test_iter</td><td>10000</td><td>测试迭代次数</td></tr><tr><td>—val_step</td><td>2000</td><td>训练val_step步之后，进行一次验证</td></tr><tr><td>—lr</td><td>-1</td><td>学习速率</td></tr><tr><td>—weight_decay</td><td>1e-5</td><td>weight decay</td></tr><tr><td>—only_test</td><td>false</td><td>只进行测试</td></tr></tbody></table></div><p>每次迭代从data_loader获取一个batch，而每个batch使用的类别与样本是随机选取的。</p><h2 id="模型设置"><a href="#模型设置" class="headerlink" title="模型设置"></a>模型设置</h2><div class="table-container"><table><thead><tr><th>参数</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>—model</td><td>proto</td><td>模型名字</td></tr><tr><td>—encoder</td><td>cnn</td><td>编码器：cnn或bert</td></tr><tr><td>—max_length</td><td>128</td><td>句子最大长度</td></tr><tr><td>—hidden_size</td><td>230</td><td>隐藏层单元数量</td></tr><tr><td>—dropout</td><td>0.0</td><td></td></tr><tr><td>—grad_iter</td><td>1</td><td>累积grad_iter次迭代的梯度</td></tr><tr><td>—optim</td><td>sgd</td><td>sgd / adam / adamw</td></tr></tbody></table></div><h2 id="保存-载入断点"><a href="#保存-载入断点" class="headerlink" title="保存/载入断点"></a>保存/载入断点</h2><div class="table-container"><table><thead><tr><th>参数</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>—load_ckpt</td><td>None</td><td>断点文件路径，</td></tr><tr><td>—save_ckpt</td><td>None</td><td>若不为None，将替换默认生成的名字</td></tr><tr><td>—ckpt_name</td><td>‘’</td><td>断点名字，加在默认生成的名字后</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>few-shot learning</tag>
      
      <tag>FewRel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Generalizing from a Few Examples - A Survey on Few-shot Learning</title>
    <link href="/2020/09/14/Few-shot/"/>
    <url>/2020/09/14/Few-shot/</url>
    
    <content type="html"><![CDATA[<p>Few-shot的一篇survey，翻译一下<strong>2.4 Taxonomy</strong>，这一节总结了当前FSL的几类方法。</p><span id="more"></span><p>为了缓解FSL在监督学习中的经验误差最小化器（empirical risk minimizer）<script type="math/tex">h_I</script>不可靠的问题，必须使用先验知识。根据先验知识对哪方面进行了增强，已有的FSL工作可分为以下几类 (Figure 2):</p><div align=center> <img src="/2020/09/14/Few-shot/Figure2.png" class=""> </div><center><font size=2>Fig. 2. Different perspectives on how FSL methods solve the few-shot problem.</font></center>- 数据。这类方法使用先验知识对$$D_{train}$$进行增强将样本的数量从$$I$$提升到$$\tilde{I}$$，其中$$\tilde{I}\gg{I}$$。将标准的机器学习模型与算法应用于增强的数据，便可获得更准确的经验误差最小化器$$h_I$$(Figure 2(a))。- 模型。这类方法使用先验知识限制$$\mathcal{H}$$的复杂度，得到一个小得多的假设空间$$\tilde{\mathcal{H}}$$如Fig.2(b)所示，灰色区域是根据先验知识确定的，不包含最优$$h^*$$的区域。在更小的$$\tilde{\mathcal{H}}$$中，$$D_{train}$$足够学习到可靠的$$h_I$$。- 算法。这类方法使用先验知识搜索$$\theta$$，其中$$\theta$$将$$\mathcal{H}$$中的最优假设$$h^*$$参数化。先验知识通过提供较好的初始化(Figure 2(c)中的灰色三角形)，或指导搜索步骤(Figure 2(c)中的灰色虚线)以改变搜索策略。对于后一种方式，最终的搜索步骤同时受到先验知识和经验风险最小化器(empirical risk minimizer)的影响。相应地，现有的工作可按该分类法进行分类，如Fig.3所示<div align=center> <img src="/2020/09/14/Few-shot/Figure3.png" class=""> </div><center><font size=2>Fig. 3. A taxonomy of FSL methods based on the focus of each method.</font></center>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>few-shot learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SIGPIPE的产生</title>
    <link href="/2020/03/11/sigpipe/"/>
    <url>/2020/03/11/sigpipe/</url>
    
    <content type="html"><![CDATA[<p>当一个进程向已经收到<code>RST</code>的<code>socket</code>写数据时，<code>SIGPIPE</code>信号会被发送给该进程。</p><span id="more"></span><p>以下是一段服务端向客户端发送响应报文的代码，第13行调用<code>write</code>向<code>fd</code>写入报文首部，第21行调用<code>write</code>向<code>fd</code>写入报文主体。若客户端连接断开，第一次<code>write</code>后，<code>fd</code>会收到<code>RST</code>，第二次<code>write</code>将产生<code>SIGPIPE</code>信号。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serve_static</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">char</span> *filename, <span class="hljs-keyword">int</span> filesize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> srcfd;<br>    <span class="hljs-keyword">char</span> *srcp, filetype[MAXLINE], buf[MAXBUF];<br> <br>    <span class="hljs-comment">/* Send response headers to client */</span><br>    get_filetype(filename, filetype);<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;HTTP/1.0 200 OK\r\n&quot;</span>);<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%sServer: Tiny Web Server\r\n&quot;</span>, buf);<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%sConnection: close\r\n&quot;</span>, buf);<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%sContent-length: %d\r\n&quot;</span>, buf, filesize);<br>    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">&quot;%sContent-type: %s\r\n\r\n&quot;</span>, buf, filetype);<br>    Rio_writen(fd, buf, <span class="hljs-built_in">strlen</span>(buf));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Response headers:\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br><br>    <span class="hljs-comment">/* Send response body to client */</span><br>    srcfd = Open(filename, O_RDONLY, <span class="hljs-number">0</span>);<br>    srcp = Mmap(<span class="hljs-number">0</span>, filesize, PROT_READ, MAP_PRIVATE, srcfd, <span class="hljs-number">0</span>);<br>    Close(srcfd);<br>    Rio_writen(fd, srcp, filesize);<br>    Munmap(srcp, filesize);<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>unix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unix</tag>
      
      <tag>网络编程</tag>
      
      <tag>CSAPP</tag>
      
      <tag>webserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一个CSAPP中Tiny Web Server的问题</title>
    <link href="/2020/03/11/issue-record/"/>
    <url>/2020/03/11/issue-record/</url>
    
    <content type="html"><![CDATA[<p>Tiny Web Server读取客户端发送来的请求头并将其输出到Terminal，此外不对首部的字段做其他处理。读取首部的代码如下：</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read_requesthdrs</span><span class="hljs-params">(<span class="hljs-keyword">rio_t</span> *rp)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[MAXLINE];<br><br>    Rio_readlineb(rp, buf, MAXLINE);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;\r\n&quot;</span>)) &#123;<br>Rio_readlineb(rp, buf, MAXLINE);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数存在的一个问题是，若客户端的连接断开，<code>Rio_readlineb(rp, buf, MAXLINE)</code>将读取到<code>EOF</code>，而循环判断条件为<code>strcmp(buf, &quot;\r\n&quot;)</code>，由于无法从客户端读取到数据，<code>buf</code>内容将永远不会更新，该循环成为死循环。为避免这种情况，<code>Rio_readlineb(rp, buf, MAXLINE)</code>返回<code>0</code>时函数应返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read_requesthdrs</span><span class="hljs-params">(<span class="hljs-keyword">rio_t</span> *rp)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> buf[MAXLINE];<br><br>    <span class="hljs-keyword">while</span>(Rio_readlineb(rp, buf, MAXLINE) &amp;&amp; <span class="hljs-built_in">strcmp</span>(buf, <span class="hljs-string">&quot;\r\n&quot;</span>)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>unix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unix</tag>
      
      <tag>网络编程</tag>
      
      <tag>CSAPP</tag>
      
      <tag>webserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS - LeetCode 跳跃游戏IV</title>
    <link href="/2020/02/09/leetcode5314/"/>
    <url>/2020/02/09/leetcode5314/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跃游戏-IV"><a href="#跳跃游戏-IV" class="headerlink" title="跳跃游戏 IV"></a>跳跃游戏 IV</h1><p>周赛没写出来的题，<a href="https://leetcode-cn.com/problems/jump-game-iv/">题目</a>如下:</p><p>给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。每一步，你可以从下标 i 跳到下标：</p><ol><li><code>i + 1 满足：i + 1 &lt; arr.length</code></li><li><code>i - 1 满足：i - 1 &gt;= 0</code></li><li><code>j 满足：arr[i] == arr[j] 且 i != j</code><br> 请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。</li></ol><p>注意：任何时候你都不能跳到数组外面。<br><span id="more"></span></p><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">输入：arr = [<span class="hljs-number">100</span>,<span class="hljs-number">-23</span>,<span class="hljs-number">-23</span>,<span class="hljs-number">404</span>,<span class="hljs-number">100</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">23</span>,<span class="hljs-number">3</span>,<span class="hljs-number">404</span>]<br>输出：<span class="hljs-number">3</span><br>解释：那你需要跳跃 <span class="hljs-number">3</span> 次，下标依次为 <span class="hljs-number">0</span> --&gt; <span class="hljs-number">4</span> --&gt; <span class="hljs-number">3</span> --&gt; <span class="hljs-number">9</span> 。下标 <span class="hljs-number">9</span> 为数组的最后一个元素的下标。<br></code></pre></td></tr></table></figure><p><strong>数据范围：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 5 * 10^4</code></li><li><code>-10^8 &lt;= arr[i] &lt;= 10^8</code></li></ul><p>这题可以用BFS解决，但是复杂度为$o(n^2)$，需要进行优化。优化的方法是：不连续使用方式3跳两次，因为使用方式3跳两次可以用直接跳一次代替。</p><p>具体的例子是：对于<code>arr = [1, 7_1, 7_2, 7_3, 7_4, 7_5, 2]</code>（把相同的<code>7</code>记为<code>7_1, 7_2, 7_3, 7_4, 7_5</code>），操作次数最少的操作为：<code>1 -&gt; 7_1 -&gt; 7_5 -&gt; 2</code>。在以<code>7_1</code>为起点考虑过<code>7_1 -&gt; 7_2</code>、<code>7_1 -&gt; 7_3</code>、<code>7_1 -&gt; 7_4</code>、<code>7_1 -&gt; 7_5</code>之后，不再使用方式3在<code>7</code>之间跳转。</p><p>具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; bucket;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minJumps</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len  = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>            bucket[arr[i]].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> book[<span class="hljs-number">50005</span>];<br>        <span class="hljs-built_in">memset</span>(book, <span class="hljs-number">-1</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(book));<br>        queue&lt;<span class="hljs-keyword">int</span>&gt; que;<br>        que.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        book[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">int</span> temp = que.<span class="hljs-built_in">front</span>();<br>            que.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (temp == len - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> nextIdx;<br>            <span class="hljs-comment">// 方式1</span><br>            <span class="hljs-keyword">if</span> (temp + <span class="hljs-number">1</span> &lt; len) &#123;<br>                nextIdx = temp + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (book[nextIdx] == <span class="hljs-number">-1</span>) &#123;<br>                    book[nextIdx] = book[temp] + <span class="hljs-number">1</span>;<br>                    que.<span class="hljs-built_in">push</span>(nextIdx);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 方式2</span><br>            <span class="hljs-keyword">if</span> (temp - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>                nextIdx = temp - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (book[nextIdx] == <span class="hljs-number">-1</span>) &#123;<br>                    book[nextIdx] = book[temp] + <span class="hljs-number">1</span>;<br>                    que.<span class="hljs-built_in">push</span>(nextIdx);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 方式3</span><br>            vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;vc = bucket[arr[temp]];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> nextIdx : vc) &#123;<br>                <span class="hljs-keyword">if</span> (book[nextIdx] == <span class="hljs-number">-1</span>) &#123;<br>                    book[nextIdx] = book[temp] + <span class="hljs-number">1</span>;<br>                    que.<span class="hljs-built_in">push</span>(nextIdx);<br>                &#125;<br>            &#125;<br>            vc.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//方式3中遍历过bucket[arr[temp]]后，将其清空</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> book[len - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如果socket服务端程序未调用bind</title>
    <link href="/2020/02/03/no-bind/"/>
    <url>/2020/02/03/no-bind/</url>
    
    <content type="html"><![CDATA[<p>unp的习题4.5：如果socket在服务端程序中，移除对<code>bind</code>的调用但继续调用<code>listen</code>，会发生什么？</p><span id="more"></span><p>结果是：在未调用<code>bind</code>的情况下，调用<code>listen</code>会为监听套接字分配临时端口号(ephemeral port)。</p><p>用以下代码进行验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;unp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-keyword">int</span><br>main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)<br>&#123;<br>    <span class="hljs-keyword">int</span>listenfd, connfd;<br>    <span class="hljs-keyword">socklen_t</span>len;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span><span class="hljs-title">servaddr</span>, <span class="hljs-title">cliaddr</span>;</span><br>    <span class="hljs-keyword">char</span>buff[MAXLINE];<br>    <span class="hljs-keyword">time_t</span>ticks;<br>    <span class="hljs-keyword">char</span> buf[MAXLINE];<br><br>    listenfd = Socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    len = <span class="hljs-keyword">sizeof</span>(servaddr);<br>    getsockname(listenfd, (SA *)&amp;servaddr, &amp;len);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Local addr: %s\n&quot;</span>, Sock_ntop((SA *) &amp;servaddr, len));<br><br><span class="hljs-comment">//    bzero(&amp;servaddr, sizeof(servaddr));</span><br><span class="hljs-comment">//    servaddr.sin_family      = AF_INET;</span><br><span class="hljs-comment">//    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="hljs-comment">//    servaddr.sin_port        = htons(9999);/* daytime server */</span><br><br><span class="hljs-comment">//    Bind(listenfd, (SA *) &amp;servaddr, sizeof(servaddr));</span><br><br>    Listen(listenfd, LISTENQ);<br><br>    len = <span class="hljs-keyword">sizeof</span>(servaddr);<br>    getsockname(listenfd, (SA *)&amp;servaddr, &amp;len);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Local addr: %s\n&quot;</span>, Sock_ntop((SA *) &amp;servaddr, len));<br><br>    <span class="hljs-keyword">for</span> ( ; ; ) &#123;<br>        len = <span class="hljs-keyword">sizeof</span>(cliaddr);<br>        connfd = Accept(listenfd, (SA *) &amp;cliaddr, &amp;len);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connection from %s, port %d\n&quot;</span>,<br>               Inet_ntop(AF_INET, &amp;cliaddr.sin_addr, buff, <span class="hljs-keyword">sizeof</span>(buff)),<br>               ntohs(cliaddr.sin_port));<br><br>        ticks = time(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">snprintf</span>(buff, <span class="hljs-keyword">sizeof</span>(buff), <span class="hljs-string">&quot;%.24s\r\n&quot;</span>, ctime(&amp;ticks));<br>        Write(connfd, buff, <span class="hljs-built_in">strlen</span>(buff));<br><br>        Close(connfd);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">▶ ./daytimetcpsrv<br>Local addr: 0.0.0.0:44833<br>connection from 127.0.0.1, port 9999<br>connection from 127.0.0.1, port 9999<br><br>▶ ./daytimetcpsrv<br>Local addr: 0.0.0.0:43641<br>connection from 127.0.0.1, port 9999<br>connection from 127.0.0.1, port 9999<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>unix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unix</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>套接字接口</title>
    <link href="/2019/12/23/SocketsInterface/"/>
    <url>/2019/12/23/SocketsInterface/</url>
    
    <content type="html"><![CDATA[<p>内容来自(摘抄自）CS: APP 11.4 The Sockets Interface.</p><span id="more"></span><h1 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h1><p>套接字接口是Unix系统用于构建网络应用程序的一套函数，通常与I/O函数结合使用。图1是在一个<em>客户端-服务器</em>交互过程中套接字接口使用的示意图。</p><p><div align=center> <img src="/2019/12/23/SocketsInterface/11-12.png" class=""> </div></p><center>图1 基于套接字的网络应用概览</center><h2 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h2><p>从Unix内核的角度来看，一个套接字就是通信的一个端点；从Unix程序的角度来看，套接字是一个具有相应文件描述符的已打开文件。</p><p>因特网的套接字地址存储在类型为<code>sockaddr_in</code>的16字节结构中。对于因特网应用，<code>sin_family</code>成员是<code>AF_INET</code>，<code>sin_port</code>成员是一个16位的端口号，<code>sin_addr</code>是32位IP地址。IP地址和端口号总是以网络字节序（大端法）存放的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* IP socket address structure */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr_in</span> &#123;</span><br>    <span class="hljs-keyword">uint16_t</span> sin_family;       <span class="hljs-comment">/* Protocol family (always AF_INET) */</span><br>    <span class="hljs-keyword">uint16_t</span> sin_port;         <span class="hljs-comment">/* Port number in network byte order */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">in_addr</span> <span class="hljs-title">sin_addr</span>;</span>   <span class="hljs-comment">/* IP address in network byte order */</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> sin_zero[<span class="hljs-number">8</span>]; <span class="hljs-comment">/* Pad to sizeof(struct sockaddr) */</span><br>&#125;;<br><br><span class="hljs-comment">/* Generic socket address structure (for connect, bind, and accept) */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> &#123;</span><br>    <span class="hljs-keyword">uint16_t</span> sa_family; <span class="hljs-comment">/* Protocol family */</span><br>    <span class="hljs-keyword">char</span> sa_data[<span class="hljs-number">14</span>];   <span class="hljs-comment">/* Address data */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>connect</code>、<code>bind</code>和<code>accept</code>函数需要一个指向与协议相关的套接字地址结构的指针，早期的C语言不存在<code>void *</code>指针，套接字函数要求一个指向通用<code>sockaddr</code>结构的指针作为参数，应用程序需要将“与协议特定的结构的指针”强制转换成<code>sockaddr *</code>指针。</p><h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a><code>socket</code>函数</h2><p>客户端和服务器使用<code>socket</code>函数创建一个<strong>套接字描述符</strong>(<em>socket descriptor</em>)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-keyword">int</span> domain, <span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> protocol)</span></span>;<br><span class="hljs-comment">// Returns: nonnegative descriptor if OK, −1 on error</span><br></code></pre></td></tr></table></figure><p><code>socket</code>返回的描述符仅是部分打开的，还不能用于读写。<code>socket</code>函数需要的参数通常由<code>getaddrinfo</code>自动生成。完成打开套接字的工作需要用到<code>connect</code>、<code>bind</code>和<code>accept</code>等函数，取决于程序是客户端还是服务器。</p><h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a><code>connect</code>函数</h2><p>客户端通过调用<code>connect</code>函数建立与服务器的连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> clientfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br><span class="hljs-comment">// Returns: 0 if OK, −1 on error</span><br></code></pre></td></tr></table></figure><p><code>connect</code>函数尝试与套接字地址为<code>addr</code>的服务器建立因特网连接，其中<code>addrlen</code>是<code>sizeof(sockaddr_in)</code>。<code>connect</code>函数会阻塞直到成功建立连接或是发生错误。与<code>socket</code>相同，<code>connect</code>函数需要的参数通常由<code>getaddrinfo</code>自动生成。</p><h2 id="bind-listen-accept函数"><a href="#bind-listen-accept函数" class="headerlink" title="bind, listen, accept函数"></a><code>bind</code>, <code>listen</code>, <code>accept</code>函数</h2><p>服务器使用<code>bind</code>, <code>listen</code>, <code>accept</code>函数与客户端建立连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">const</span> struct sockaddr *addr, <span class="hljs-keyword">socklen_t</span> addrlen)</span></span>;<br><span class="hljs-comment">// Returns: 0 if OK, −1 on error</span><br></code></pre></td></tr></table></figure><p><code>bind</code>函数向内核请求将<code>addr</code>中的服务器地址关联到套接字描述符<code>sockfd</code>，参数<code>addrlen</code>是<code>sizeof(sockaddr_in)</code>。与<code>socket</code>和<code>connect</code>相同，<code>bind</code>函数需要的参数通常由<code>getaddrinfo</code>自动生成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sockfd, <span class="hljs-keyword">int</span> backlog)</span></span>;<br><span class="hljs-comment">// Returns: 0 if OK, −1 on error</span><br></code></pre></td></tr></table></figure><p>客户端是是发起连接请求的主动实体，服务器是等待来自客户端请求的被动实体。默认情况下，内核把<code>socket</code>函数创建的描述符当作<strong>主动套接字</strong>(<em>active socket</em>)，它将被用于连接的客户端。服务器可以调用<code>listen</code>函数，将一个主动套接字转化为一个<strong>监听套接字</strong>(<em>listening socket</em>)。</p><p>服务器通过调用<code>accept</code>函数等待来自客户端的连接。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-keyword">int</span> listenfd, struct sockaddr *addr, <span class="hljs-keyword">int</span> *addrlen)</span></span>;<br><span class="hljs-comment">// Returns: nonnegative connected descriptor if OK, −1 on error</span><br></code></pre></td></tr></table></figure><p><code>accepet</code>函数等待来自客户端的连接请求到达监听关键字<code>listenfd</code>，然后将客户端的套接字地址填入<code>addr</code>，并返回一个<strong>已连接描述符</strong>(<em>connected descriptor</em>)，该描述符可以通过Unix I/O函数与客户端通信，图2描述了客户端与服务器连接的过程。</p><p><div align=center> <img src="/2019/12/23/SocketsInterface/11-14.png" class=""> </div></p><center>图2 监听描述符与已连接描述符</center><h2 id="getaddrinfo与getnameinfo"><a href="#getaddrinfo与getnameinfo" class="headerlink" title="getaddrinfo与getnameinfo"></a><code>getaddrinfo</code>与<code>getnameinfo</code></h2><p>Linux提供了<code>getaddrinfo</code>与<code>getnameinfo</code>，可以使套接字地址结构与用字符串表示的主机名、主机地址、服务名和端口号之间相互转换。我们可以将这两个函数与套接字接口结合使用，编写与IP协议版本无关的网络应用程序。</p><p><code>getaddrinfo</code>函数将字符串形式的主机名、主机地址、服务名和端口号转化为套接字地址结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getaddrinfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *host, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *service,</span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">const</span> struct addrinfo *hints,</span></span><br><span class="hljs-function"><span class="hljs-params">                struct addrinfo **result)</span></span>;<br><span class="hljs-comment">// Returns: 0 if OK, nonzero error code on error</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeaddrinfo</span><span class="hljs-params">(struct addrinfo *result)</span></span>;<br><span class="hljs-comment">// Returns: nothing</span><br><br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-title">gai_strerror</span><span class="hljs-params">(<span class="hljs-keyword">int</span> errcode)</span></span>;<br><span class="hljs-comment">// Returns: error message</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ai_flags;              <span class="hljs-comment">/* Hints argument flags */</span><br>    <span class="hljs-keyword">int</span> ai_family;             <span class="hljs-comment">/* First arg to socket function */</span><br>    <span class="hljs-keyword">int</span> ai_socktype;           <span class="hljs-comment">/* Second arg to socket function */</span><br>    <span class="hljs-keyword">int</span> ai_protocol;           <span class="hljs-comment">/* Third arg to socket function */</span><br>    <span class="hljs-keyword">char</span> *ai_canonname;        <span class="hljs-comment">/* Canonical hostname */</span><br>    <span class="hljs-keyword">size_t</span> ai_addrlen;         <span class="hljs-comment">/* Size of ai_addr struct */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sockaddr</span> *<span class="hljs-title">ai_addr</span>;</span>  <span class="hljs-comment">/* Ptr to socket address structure */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> *<span class="hljs-title">ai_next</span>;</span>  <span class="hljs-comment">/* Ptr to next item in linked list */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><code>host</code>参数可以是域名或IP地址，<code>service</code>参数可以是服务名（http、ftp等）或端口号。可选的参数<code>hint</code>是一个<code>addrinfo</code>结构，用于控制<code>getaddrinfo</code>返回套接字地址的种类，比如可以设置<code>ai_family</code>为<code>AF_INET</code>限制只返回IPv4地址。<code>getaddrinfo</code>的结果存放在<code>result</code>中，<code>result</code>指向一个<code>addrinfo</code>的链表，链表中的每一项都指向一个套接字地址结构，如图3所示。</p><p><div align=center> <img src="/2019/12/23/SocketsInterface/11-15.png" class=""> </div></p><p><center>图3 getaddrinfo返回的数据结构</center><br>通常，客户端调用<code>getaddrinfo</code>，再遍历结果链表，对链表中每一个套接字地址依次调用<code>socket</code>与<code>connect</code>直到成功建立连接。</p><hr><p><code>getnameinfo</code>的功能与<code>getaddrinfo</code>相反，它将套接字地址结构转换为字符串形式的主机名与服务名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getnameinfo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct sockaddr *sa, <span class="hljs-keyword">socklen_t</span> salen,</span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">char</span> *host, <span class="hljs-keyword">size_t</span> hostlen,</span></span><br><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">char</span> *service, <span class="hljs-keyword">size_t</span> servlen, <span class="hljs-keyword">int</span> flags)</span></span>;<br><span class="hljs-comment">// Returns: 0 if OK, nonzero error code on error</span><br></code></pre></td></tr></table></figure><p>以下为使用<code>getaddrinfo</code>与<code>getnameinfo</code>的一个示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;csapp.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> *<span class="hljs-title">p</span>, *<span class="hljs-title">listp</span>, <span class="hljs-title">hints</span>;</span><br>    <span class="hljs-keyword">char</span> buf[MAXLINE];<br>    <span class="hljs-keyword">int</span> rc, flags;<br><br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;usage: %s &lt;domain name&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Get a list of addrinfo records */</span><br>    <span class="hljs-built_in">memset</span>(&amp;hints, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct addrinfo));                         <br>    hints.ai_family = AF_INET;       <span class="hljs-comment">/* IPv4 only */</span><br>    hints.ai_socktype = SOCK_STREAM; <span class="hljs-comment">/* Connections only */</span><br>    <span class="hljs-keyword">if</span> ((rc = getaddrinfo(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, &amp;hints, &amp;listp)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;getaddrinfo error: %s\n&quot;</span>, gai_strerror(rc));<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Walk the list and display each IP address */</span><br>    flags = NI_NUMERICHOST; <span class="hljs-comment">/* Display address string instead of domain name */</span><br>    <span class="hljs-keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;<br>        Getnameinfo(p-&gt;ai_addr, p-&gt;ai_addrlen, buf, MAXLINE, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, flags);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>    &#125; <br><br>    <span class="hljs-comment">/* Clean up */</span><br>    Freeaddrinfo(listp);<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="套接字接口的包装"><a href="#套接字接口的包装" class="headerlink" title="套接字接口的包装"></a>套接字接口的包装</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open_clientfd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *hostname, <span class="hljs-keyword">char</span> *port)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> clientfd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> <span class="hljs-title">hints</span>, *<span class="hljs-title">listp</span>, *<span class="hljs-title">p</span>;</span><br>    <br>    <span class="hljs-comment">/* Get a list of potential server addresses */</span><br>    <span class="hljs-built_in">memset</span>(&amp;hints, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct addrinfo));<br>    hints.ai_socktype = SOCK_STREAM; <span class="hljs-comment">/* Open a connection */</span><br>    hints.ai_flags = AI_NUMERICSERV; <span class="hljs-comment">/* ... using a numeric port arg. */</span><br>    hints.ai_flags |= AI_ADDRCONFIG; <span class="hljs-comment">/* Recommended for connections */</span><br>    Getaddrinfo(hostname, port, &amp;hints, &amp;listp);<br>    <br>    <span class="hljs-comment">/* Walk the list for one that we can successfully connect to */</span><br>    <span class="hljs-keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;<br>        <span class="hljs-comment">/* Create a socket descriptor */</span><br>        <span class="hljs-keyword">if</span> ((clientfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">/* Socket failed, try the next */</span><br>        <br>        <span class="hljs-comment">/* Connect to the server */</span><br>        <span class="hljs-keyword">if</span> (connect(clientfd, p-&gt;ai_addr, p-&gt;ai_addrlen) != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* Success */</span><br>        Close(clientfd); <span class="hljs-comment">/* Connect failed, try another */</span><br>    &#125;<br><br>    <span class="hljs-comment">/* Clean up */</span><br>    Freeaddrinfo(listp);<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-comment">/* All connects failed */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">else</span>    <span class="hljs-comment">/* The last connect succeeded */</span><br>        <span class="hljs-keyword">return</span> clientfd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open_listenfd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *port)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">addrinfo</span> <span class="hljs-title">hints</span>, *<span class="hljs-title">listp</span>, *<span class="hljs-title">p</span>;</span><br>    <span class="hljs-keyword">int</span> listenfd, rc, optval=<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/* Get a list of potential server addresses */</span><br>    <span class="hljs-built_in">memset</span>(&amp;hints, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(struct addrinfo));<br>    hints.ai_socktype = SOCK_STREAM;             <span class="hljs-comment">/* Accept connections */</span><br>    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; <span class="hljs-comment">/* ... on any IP address */</span><br>    hints.ai_flags |= AI_NUMERICSERV;            <span class="hljs-comment">/* ... using port number */</span><br>    <span class="hljs-keyword">if</span> ((rc = getaddrinfo(<span class="hljs-literal">NULL</span>, port, &amp;hints, &amp;listp)) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;getaddrinfo failed (port %s): %s\n&quot;</span>, port, gai_strerror(rc));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Walk the list for one that we can bind to */</span><br>    <span class="hljs-keyword">for</span> (p = listp; p; p = p-&gt;ai_next) &#123;<br>        <span class="hljs-comment">/* Create a socket descriptor */</span><br>        <span class="hljs-keyword">if</span> ((listenfd = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) &lt; <span class="hljs-number">0</span>) <br>            <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">/* Socket failed, try the next */</span><br><br>        <span class="hljs-comment">/* Eliminates &quot;Address already in use&quot; error from bind */</span><br>        setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,    <span class="hljs-comment">//line:netp:csapp:setsockopt</span><br>                   (<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)&amp;optval , <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));<br><br>        <span class="hljs-comment">/* Bind the descriptor to the address */</span><br>        <span class="hljs-keyword">if</span> (bind(listenfd, p-&gt;ai_addr, p-&gt;ai_addrlen) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">/* Success */</span><br>        <span class="hljs-keyword">if</span> (close(listenfd) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* Bind failed, try the next */</span><br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;open_listenfd close failed: %s\n&quot;</span>, strerror(errno));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/* Clean up */</span><br>    freeaddrinfo(listp);<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-comment">/* No address worked */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-comment">/* Make it a listening socket ready to accept connection requests */</span><br>    <span class="hljs-keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="hljs-number">0</span>) &#123;<br>        close(listenfd);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> listenfd;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>unix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unix</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FewRel简单笔记</title>
    <link href="/2019/12/14/FewRel/"/>
    <url>/2019/12/14/FewRel/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>FewRel是一个小样本关系分类数据集，该数据集由Wikipedia上的100种关系中的70000个句子组成，并由人工进行标注。<span id="more"></span> 每个句子的关系首先通过远程离监督方法来识别，然后由人工修正。 我们将最新的SOTA小样本学习方法用于关系分类，并对这些方法进行全面评估。 实证结果表明，即使是最有效的小样本学习模型也难以完成这项任务，尤其是与人类的表现仍存在差距。 文章还指出，解决改任务需要多种不同的推理能力。 少打关系分类仍然是一个复杂的问题，仍需进一步研究，文章的详细分析了当前结果，并为未来的研究指明了多个方向。 有关数据集和基线的所有详细信息和资源均在<a href="http://zhuhao.me/fewrel">http://zhuhao.me/fewrel</a> 上发布。</p><p>关系分类（RC）是NLP中的一项重要任务，旨在确定给定句子中两个实体之间的正确关系。为完成该任务目前已有很多相关工作，包括核方法（Zelenko等，2002； Mooney和Bunescu，2006），嵌入方法（Gormley等，2015）和神经网络方法（Zeng等，2014）。这些常规模型的性能在很大程度上取决于费时且费力的已标注数据，这使其泛化能力受到限制。采用远程监督是缓解RC的主要方法（Mintz等人; Riedel等人; Hoffmann等人，2011; Surdeanu等人，2012; Zeng等人，2015; Lin等人， 2016），远程监督通过启发式对齐知识库（KB）和文本以自动注释足够数量的训练样本。我们使用基准数据集NYT-10评估了Lin等人提出的模型（2016），该工作是随后是最新的技术水平（Zeng等，2017; Ji等，2017; Huang和Wang，2017; Wu等，2017; Liu等，2017）的基础。尽管在常见的关系上取得了不错的结果，但是当关系的训练样本数量减少时，分类准确率急剧下降。 NYT-10中大约58％的关系是长尾关系，少于100个实例。此外，远距离监督存在标注错误的问题，这使得对长尾关系进行分类变得更加困难。因此，有必要研究如何在小样本条件下训练RC模型。</p><p>早期的方法使用<strong>迁移学习</strong>，模型先在类别常见且样本充足的数据集上训练，然后在只有少量样本的不常见类别数据上微调。</p><p><strong>尺度学习方法</strong>学习类别之间的距离分布。</p><p><strong>元学习</strong>支持模型从之前的经验中学习“快速学习”并快速归纳出新概念的能力。</p>]]></content>
    
    
    <categories>
      
      <category>deep learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>few-shot learning</tag>
      
      <tag>relation classification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csapp shell lab 相关</title>
    <link href="/2019/12/05/shelllab/"/>
    <url>/2019/12/05/shelllab/</url>
    
    <content type="html"><![CDATA[<p>CS: APP 的<a href="http://csapp.cs.cmu.edu/3e/labs.html">Shell Lab</a>，要求实现一个支持作业控制的Unix shell。</p><span id="more"></span><h1 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h1><ol><li>安装信号捕捉函数</li><li>在循环中读取命令，创建子进程运行命令。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * main - The shell&#x27;s main routine </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* Install the signal handlers */</span><br>    <span class="hljs-comment">/* Execute the shell&#x27;s read/eval loop */</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">/* Read command line */</span><br>        <span class="hljs-keyword">if</span> ((fgets(cmdline, MAXLINE, <span class="hljs-built_in">stdin</span>) == <span class="hljs-literal">NULL</span>) &amp;&amp; ferror(<span class="hljs-built_in">stdin</span>))<br>            app_error(<span class="hljs-string">&quot;fgets error&quot;</span>);<br>        <span class="hljs-keyword">if</span> (feof(<span class="hljs-built_in">stdin</span>)) &#123; <span class="hljs-comment">/* End of file (ctrl-d) */</span><br>            fflush(<span class="hljs-built_in">stdout</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-comment">/* Evaluate the command line */</span><br>        eval(cmdline);<br>        fflush(<span class="hljs-built_in">stdout</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">/* control never reaches here */</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="调用waitpid获取子进程终止状态"><a href="#调用waitpid获取子进程终止状态" class="headerlink" title="调用waitpid获取子进程终止状态"></a>调用waitpid获取子进程终止状态</h1><p>进程停止（stopped）或终止（terminated）时，会向父进程发送SIGCHLD信号，该信号的默认动作是忽略；父进程可以捕捉SIGCHLD信号，在信号处理函数中根据子进程状态做相应处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> *wstatus, <span class="hljs-keyword">int</span> options)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">pid_t</span> pid;<br>    <span class="hljs-keyword">int</span> status;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job_t</span> *<span class="hljs-title">job</span>;</span><br><br>    <span class="hljs-keyword">while</span> ((pid = waitpid(<span class="hljs-number">-1</span>, &amp;status, WNOHANG|WUNTRACED)) &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* Reap a zombie child */</span><br>        <span class="hljs-keyword">if</span>((job = getjobpid(jobs, pid)) != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">/* Should always get here */</span><br>            <span class="hljs-keyword">if</span> (WIFEXITED(status)) &#123;<br>                deletejob(jobs, pid);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSIGNALED(status)) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) terminated by signal %d (from pid %d)\n&quot;</span>,<br>                        pid2jid(pid), pid, WTERMSIG(status), getpid());<br>                deletejob(jobs, pid);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (WIFSTOPPED(status)) &#123;<br>                job-&gt;state = ST;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Job [%d] (%d) stoped by signal %d (from pid %d)\n&quot;</span>,<br>                        pid2jid(pid), pid, WSTOPSIG(status), getpid());<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><ul><li><p><code>waitpid</code>的参数<code>options</code>或者是0，或者是以下几个常量按位或运算的结果：</p><ul><li><code>WNOHANG</code>：若没有由<code>pid</code>指定的进程状态发生改变，<code>waitpid</code>立刻返回，返回值为0；</li><li><code>WUNTRACED</code>：若有由<code>pid</code>指定的进程停止（stopped），<code>waitpid</code>也会返回；</li><li><code>WCONTINUED</code>：若有由<code>pid</code>指定的进程在停止（stopped）状态下收到<code>SIGCONT</code>信号而继续运行，<code>waitpid</code>也会返回。</li></ul></li><li><p>一个以及发出但未被接收的信号叫做<strong>待处理信号</strong>（pending signal）。在任何时刻，每种类型的信号都至多只有一个待处理信号。如果一个进程有一个类型为<em>k</em>的待处理信号，那么接下来任何发送到这个进程的类型为<em>k</em>的信号都不会排队等待，它们都会被直接丢弃。</p><p>因此，shell主进程接收到一个来自子进程的SIGCHLD信号并运行信号捕捉函数时，可能会有其他子进程的运行状态发生改变并向shell主进程发送SIGCHLD信号，shell主进程需要处理所有运行状态发生改变的子进程。</p><p><code>sigchld_handler</code>第10行的<code>while ((pid = waitpid(-1, &amp;status, WNOHANG|WUNTRACED)) &gt; 0)</code>，将<code>waitpid</code>的返回值作为循环判断条件，只有处理完所有停止（stopped）或终止（terminated）的子进程时<code>waitpid</code>返回0，循环结束。</p></li></ul><h1 id="前台与后台"><a href="#前台与后台" class="headerlink" title="前台与后台"></a>前台与后台</h1><ul><li>shell用作业（job）来表示执行一个命令行而创建的进程（一个或多个），这些进程属于同一个进程组。任何时候，至多可以有一个前台作业以及0个或多个后台作业，下图是一个有一个前台作业和两个后台作业的shell。<br><div align=center> <img src="/2019/12/05/shelllab/8-28.png" class=""> </div><br>由键盘输入产生的信号（SIGINT、SIGTSTP等）会发送给前台进程组中的所有进程。函数<code>tcsetpgrp</code>可以将指定进程组设置为前台进程组。</li></ul><h1 id="SIGTTIN与SIGTTOU"><a href="#SIGTTIN与SIGTTOU" class="headerlink" title="SIGTTIN与SIGTTOU"></a>SIGTTIN与SIGTTOU</h1><p><code>SIGTTIN</code>与<code>SIGTTOU</code>属于作业控制信号，当任何一个后台作业中进程试图读终端时，<code>SIGTTIN</code>信号会被发送给该作业中的所有进程；类似的，当任何一个后台作业中进程试图写终端时，<code>SIGTTOU</code>信号会被发送给该作业中的所有进程。shell主进程应该忽略这些作业控制信号，以避免被意外地停止。</p><h1 id="使用sigprocmask同步进程"><a href="#使用sigprocmask同步进程" class="headerlink" title="使用sigprocmask同步进程"></a>使用<code>sigprocmask</code>同步进程</h1><p>函数<code>sigprocmask</code>可以获取和改变信号屏蔽字，通过设置信号屏蔽字可以实现进程的同步。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">initjobs(); <span class="hljs-comment">/* Initialize the job list */</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    Sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); <span class="hljs-comment">/* Block SIGCHLD */</span><br>    <span class="hljs-keyword">if</span> ((pid = Fork()) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* Child process */</span><br>        Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">/* Unblock SIGCHLD */</span><br>        Execve(<span class="hljs-string">&quot;/bin/date&quot;</span>, argv, <span class="hljs-literal">NULL</span>);<br>    &#125;<br>    Sigprocmask(SIG_BLOCK, &amp;mask_all, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">/* Parent process */</span><br>    addjob(pid); <span class="hljs-comment">/* Add the child to the job list */</span><br>    Sigprocmask(SIG_SETMASK, &amp;prev_one, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">/* Unblock SIGCHLD */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>主进程在创建子进程之前屏蔽了<code>SIGCHLD</code>信号，在执行完<code>addjob(pid)</code>后再解除屏蔽<code>SIGCHLD</code>，保证了在执行<code>SIGCHLD</code>的信号处理函数之前已经执行了<code>addjob(pid)</code>。</p>]]></content>
    
    
    <categories>
      
      <category>unix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unix</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板友元</title>
    <link href="/2019/10/19/TemplateFriends/"/>
    <url>/2019/10/19/TemplateFriends/</url>
    
    <content type="html"><![CDATA[<h1 id="模板友元"><a href="#模板友元" class="headerlink" title="模板友元"></a>模板友元</h1><p>函数模板与类模板的声明都可以在非局部类或类模板中使用<code>friend</code>说明符修饰（但只有函数模板可以定义在授予它友元权限的类或类模板中）。在这种情况下，所有特例化的模板都会成为一个友元，无论他是被隐式实例化、部分特例化或显式特例化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span> <span class="hljs-comment">// every B&lt;T&gt; is a friend of A</span><br> <br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T)</span> </span>&#123;&#125; <span class="hljs-comment">// every f&lt;T&gt; is a friend of A</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>友元声明不能用于部分特例化，但可以用于完全（显式）特例化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &#123;</span>&#125;; <span class="hljs-comment">// primary</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;</span>T*&gt; &#123;&#125;; <span class="hljs-comment">// partial</span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;</span><span class="hljs-keyword">int</span>&gt; &#123;&#125;; <span class="hljs-comment">// full</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> &#123;</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span> <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;</span>T*&gt;; <span class="hljs-comment">// error!</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;</span><span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">// OK</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当友元声明用于一个函数模板的完全特例化时，不能使用<code>inline</code>关键字和默认参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-keyword">void</span> f&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">int</span>);<br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> &#123;</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> f&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>); <span class="hljs-comment">// error: default args not allowed</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="模板友元运算符"><a href="#模板友元运算符" class="headerlink" title="模板友元运算符"></a>模板友元运算符</h1><p>模板友元的一个常见用途是声明一个非成员运算符重载其默认操作；例如，对用户定义的<code>Foo&lt;T&gt;</code>声明<code>operator&lt;&lt;(std::ostream&amp;, const Foo&lt;T&gt;&amp;)</code>。</p><p>该运算符可以定义在类内部，这样的效果是为每一个类型<code>T</code>生成一个独立的非模板的<code>operator&lt;&lt;</code>，并使这个非模板的<code>operator&lt;&lt;</code>成为<code>Foo&lt;T&gt;</code>的友元。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">const</span> T&amp; val) : <span class="hljs-built_in">data</span>(val) &#123;&#125;<br> <span class="hljs-keyword">private</span>:<br>    T data;<br> <br>    <span class="hljs-comment">// generates a non-template operator&lt;&lt; for this T</span><br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-keyword">const</span> Foo&amp; obj)<br>    &#123;<br>        <span class="hljs-keyword">return</span> os &lt;&lt; obj.data;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Foo&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">1.23</span>)</span></span>;<br>    std::cout &lt;&lt; obj &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者函数模板必须在类之前进行模板声明，在这种情况下<code>Foo&lt;T&gt;</code>之内的友元声明可使用类型<code>T</code>进行完全特例化的<code>operator&lt;&lt;</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span>;</span> <span class="hljs-comment">// forward declare to make function declaration possible</span><br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// declaration</span><br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp;, <span class="hljs-keyword">const</span> Foo&lt;T&gt;&amp;);<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">const</span> T&amp; val) : <span class="hljs-built_in">data</span>(val) &#123;&#125;<br> <span class="hljs-keyword">private</span>:<br>    T data;<br> <br>    <span class="hljs-comment">// refers to a full specialization for this particular T </span><br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt; &lt;&gt; (std::ostream&amp;, <span class="hljs-keyword">const</span> Foo&amp;);<br>    <span class="hljs-comment">// note: this relies on template argument deduction in declarations</span><br>    <span class="hljs-comment">// can also specify the template argument with operator&lt;&lt; &lt;T&gt;&quot;</span><br>&#125;;<br> <br><span class="hljs-comment">// definition</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-keyword">const</span> Foo&lt;T&gt;&amp; obj)<br>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; obj.data;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Foo&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">1.23</span>)</span></span>;<br>    std::cout &lt;&lt; obj &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>内容来自：<a href="https://en.cppreference.com/w/cpp/language/friend">https://en.cppreference.com/w/cpp/language/friend</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Templates And Generic Programming</title>
    <link href="/2019/10/14/TemplatesAndGenericProgramming/"/>
    <url>/2019/10/14/TemplatesAndGenericProgramming/</url>
    
    <content type="html"><![CDATA[<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><ul><li><p>可以定义一个通用的<strong>函数模板</strong>（function template），而不是为每个类型都定义一个新函数，来生成针对特定类型的新版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;v1, <span class="hljs-keyword">const</span> T &amp;v2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (v1 &lt; v2) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (v2 &lt; v1) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参，并使用推断出的模板参数<strong>实例化</strong>（instantiate）一个特定版本的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// instantiates int compare(const int&amp;, const int&amp;)</span><br>cout &lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;       <span class="hljs-comment">// T is int</span><br><span class="hljs-comment">// instantiates int compare(const vector&lt;int&gt;&amp;, const vector&lt;int&gt;&amp;)</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; vec1&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, vec2&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>cout &lt;&lt; <span class="hljs-built_in">compare</span>(vec1, vec2) &lt;&lt; endl; <span class="hljs-comment">// T is vector&lt;int&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>模板类型参数前必须使用关键字<code>class</code>或<code>typename</code>，并且在模板参数列表中，这两个关键字的含义相同，可以互换使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// error: must precede U with either typename or class</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, U&gt; <span class="hljs-function">T <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp;, <span class="hljs-keyword">const</span> U&amp;)</span></span>;<br><span class="hljs-comment">// ok: no distinction between typename and class in a template parameter list</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U</span>&gt;</span> <span class="hljs-built_in">calc</span> (<span class="hljs-keyword">const</span> T&amp;, <span class="hljs-keyword">const</span> U&amp;);<br></code></pre></td></tr></table></figure></li><li><p>除了定义类型参数，还可以在模板中定义<strong>非类型参数</strong>（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字<code>class</code>或<code>typename</code>来指定非类型参数。</p></li><li><p>当以一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替，这些值必须是常量表达式。对于以下函数模板，调用<code>compare(&quot;hi&quot;, &quot;mom&quot;)</code>会实例化出<code>compare(const char (&amp;p1)[3], const char (&amp;p1)[4])</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">unsigned</span> N, <span class="hljs-keyword">unsigned</span> M&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> (&amp;p1)[N], <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> (&amp;p2)[M])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1, p2);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。绑定到非类型整型参数的实参必须是一个常量表达式，绑定到指针或引用类型非类型参数的实参必须具有静态的生存期。</p></li><li>对于模板，为了生成一个实例化的版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，模板的头文件通常既包括声明也包括定义。</li></ul><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><ul><li><strong>类模板</strong>（class template）是用来生成类的蓝图的，与函数模板不同的是，编译器不能为类模板推断模板函数类型，我们必须为类模板提供<strong>显式模板实参</strong>（explicit template）。</li><li><p>默认情况下，一个类模板的成员函数只有当程序用到他时才进行实例化。这个特性使得即使某种类型不能完全符合模板操作的要求，我们仍能用该类型实例化类。</p></li><li><p>当我们使用一个类模板类型时必须提供模板实参，但这规则有个例外。在类模板自己的作用域中，可以直接使用模板名而不提供实参，编译器将假定我们使用的类型与成员实例化所用的类型一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// BlobPtr throws an exception on attempts to access a nonexistent element</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlobPtr</span></span><br><span class="hljs-class"><span class="hljs-title">public</span>:</span><br>    <span class="hljs-built_in">BlobPtr</span>(): <span class="hljs-built_in">curr</span>(<span class="hljs-number">0</span>) &#123; &#125;<br>    <span class="hljs-built_in">BlobPtr</span>(Blob&lt;T&gt; &amp;a, <span class="hljs-keyword">size_t</span> sz = <span class="hljs-number">0</span>):<br>            <span class="hljs-built_in">wptr</span>(a.data), <span class="hljs-built_in">curr</span>(sz) &#123; &#125;<br>    T&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span><br>    &#123; <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">check</span>(curr, <span class="hljs-string">&quot;dereference past end&quot;</span>);<br>      <span class="hljs-keyword">return</span> (*p)[curr];  <span class="hljs-comment">// (*p) is the vector to which this object points</span><br>    &#125;<br>    <span class="hljs-comment">// increment and decrement</span><br>    BlobPtr&amp; <span class="hljs-keyword">operator</span>++();        <span class="hljs-comment">// prefix operators</span><br>    BlobPtr&amp; <span class="hljs-keyword">operator</span>--();<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// check returns a shared_ptr to the vector if the check succeeds</span><br>    std::shared_ptr&lt;std::vector&lt;T&gt;&gt;<br>        <span class="hljs-built_in">check</span>(std::<span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">const</span> std::string&amp;) <span class="hljs-keyword">const</span>;<br>    <span class="hljs-comment">// store a weak_ptr, which means the underlying vector might be destroyed</span><br>    std::weak_ptr&lt;std::vector&lt;T&gt;&gt; wptr;<br>    std::<span class="hljs-keyword">size_t</span> curr;      <span class="hljs-comment">// current position within the array</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板自身：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// forward declarations needed for friend declarations in Blob</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlobPtr</span>;</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blob</span>;</span> <span class="hljs-comment">// needed for parameters in operator==</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Blob&lt;T&gt;&amp;, <span class="hljs-keyword">const</span> Blob&lt;T&gt;&amp;);<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blob</span> &#123;</span><br>    <span class="hljs-comment">// each instantiation of Blob grants access to the version of</span><br>    <span class="hljs-comment">// BlobPtr and the equality operator instantiated with the same type</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlobPtr</span>&lt;</span>T&gt;;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==&lt;T&gt;<br>           (<span class="hljs-keyword">const</span> Blob&lt;T&gt;&amp;, <span class="hljs-keyword">const</span> Blob&lt;T&gt;&amp;);<br>    <span class="hljs-comment">// other members as in § 12.1.1 (p. 456)</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>为了让所有实例称为友元，友元声明中必须使用与类模板本身不同的模板参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// forward declaration necessary to befriend a specific instantiation of a template</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &#123;</span>  <span class="hljs-comment">//  C is an ordinary, nontemplate class</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal</span>&lt;</span>C&gt;;  <span class="hljs-comment">// Pal instantiated with class C is a friend to C</span><br>    <span class="hljs-comment">// all instances of Pal2 are friends to C;</span><br>    <span class="hljs-comment">// no forward declaration required when we befriend all instantiations</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal2</span>;</span><br>&#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C2</span> &#123;</span> <span class="hljs-comment">// C2 is itself a class template</span><br>    <span class="hljs-comment">// each instantiation of C2 has the same instance of Pal as a friend</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal</span>&lt;</span>T&gt;;  <span class="hljs-comment">// a template declaration for Pal must be in scope</span><br>    <span class="hljs-comment">// all instances of Pal2 are friends of each instance of C2, prior declaration needed</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> X&gt; <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal2</span>;</span><br>    <span class="hljs-comment">// Pal3 is a nontemplate class that is a friend of every instance of C2</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal3</span>;</span>    <span class="hljs-comment">// prior declaration for Pal3 not needed</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>在C++ 11标准中，可以将模板类型参数声明为友元：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> &#123;</span><br><span class="hljs-keyword">friend</span> Type; <span class="hljs-comment">// grants access to the type used to instantiate Bar</span><br>    <span class="hljs-comment">//  ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>C++ 11标准允许我们为模板类定义一个类型别名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">using</span> twin = pair&lt;T, T&gt;;<br>twin&lt;string&gt; authors; <span class="hljs-comment">// authors is a pair&lt;string, string&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>对于类模板的<code>static</code>成员，类模板的每个实例都有一个独有的<code>static</code>对象。因此，与定义模板的成员函数相似，<code>static</code>数据成员也需要定义为模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-keyword">static</span> std::<span class="hljs-keyword">size_t</span> <span class="hljs-title">count</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> ctr; &#125;<br>   <span class="hljs-comment">// other interface members</span><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-keyword">static</span> std::<span class="hljs-keyword">size_t</span> ctr;<br>   <span class="hljs-comment">// other implementation members</span><br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="hljs-number">0</span>; <span class="hljs-comment">// define and initialize ctr</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><ul><li><p>默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。因此，在使用一个模板类型参数的类型成员，就必须显式告诉编译器改名字是一个类型，我们通过使用关键字<code>typename</code>（而不是<code>class</code>）实现这一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">typename</span> T::value_type <span class="hljs-title">top</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!c.<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> c.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">typename</span> T::<span class="hljs-built_in">value_type</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在C++11标准中，我们可以为函数模板和类模板提供<strong>默认模板实参</strong>（default template argument）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// compare has a default template argument, less&lt;T&gt;</span><br><span class="hljs-comment">// and a default function argument, F()</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> F = less&lt;T&gt;&gt;<br><span class="hljs-keyword">int</span> <span class="hljs-built_in">compare</span>(<span class="hljs-keyword">const</span> T &amp;v1, <span class="hljs-keyword">const</span> T &amp;v2, F f = <span class="hljs-built_in">F</span>())<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(v1, v2)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">f</span>(v2, v1)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><ul><li><p>一个类（普通类或类模板）可以包含本身是模板的成员函数，这种成员被称为<strong>成员模板</strong>（member template），成员模板不能是虚函数。</p></li><li><p>在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Blob</span> &#123;</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt; <span class="hljs-built_in">Blob</span>(It b, It e);<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;     <span class="hljs-comment">// type parameter for the class</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;    <span class="hljs-comment">// type parameter for the constructor</span><br>    Blob&lt;T&gt;::<span class="hljs-built_in">Blob</span>(It b, It e):<br>              <span class="hljs-built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e)) &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><ul><li><p>在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重，在C++ 11标准中，可以通过<strong>显式实例化</strong>（explicit instantiation）来避免这种开销。一个显式实例化有如下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> declaration; <span class="hljs-comment">// instantiation declaration</span><br><span class="hljs-keyword">template</span> declaration;        <span class="hljs-comment">// instantiation definition</span><br></code></pre></td></tr></table></figure></li><li><p>当编译器遇到<code>extern</code>模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为<code>extern</code>就表示承诺该程序在其他位置有该实例化的一个非<code>extern</code>声明（定义）。</p></li><li>一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。</li></ul><h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><ul><li>从函数函数实参来确定模板实参的过程被称为<strong>模板实参推断</strong>（template argument deduction）。</li></ul><h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><ul><li>只有有限的几种类型转换会自动地应用与实参，编译器通常不是对实参进行类型转换，而是生成一个新的模板实例。</li><li>与往常一样，顶层<code>const</code>无论在形参中还是实参中，都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项：<ul><li><code>const</code>转换</li><li>指针或函数指针转换</li></ul></li></ul><h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><ul><li>显式模板实参按由左至右的顺序与对应的模板参数匹配，只有尾部（最右）参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。</li><li>对于模板类型参数已经显式指定的实参，也会进行正常的类型转换：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">long</span> lng;<br><span class="hljs-built_in">compare</span>(lng, <span class="hljs-number">1024</span>);       <span class="hljs-comment">// error: template parameters don&#x27;t match</span><br>compare&lt;<span class="hljs-keyword">long</span>&gt;(lng, <span class="hljs-number">1024</span>); <span class="hljs-comment">// ok: instantiates compare(long, long)</span><br>compare&lt;<span class="hljs-keyword">int</span>&gt;(lng, <span class="hljs-number">1024</span>);  <span class="hljs-comment">// ok: instantiates compare(int, int)</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3><ul><li><p>由于尾置返回出现在参数列表之后，它可以使用函数的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// a trailing return lets us declare the return type after the parameter list is seen</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br>auto fcn(It beg, It end) -&gt; decltype(*beg)<br>&#123;<br>    <span class="hljs-comment">// process the range</span><br>    <span class="hljs-keyword">return</span> *beg;  <span class="hljs-comment">// return a reference to an element from the range</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>为了获得元素类型，可以使用标准库的<strong>类型转换</strong>（type transformation）模板。可以使用<code>remove_reference</code>来获得元素类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> It&gt;<br>auto fcn2(It beg, It end) -&gt; typename remove_reference&lt;decltype(*beg)&gt;::type<br>&#123;<br>    <span class="hljs-comment">// process the range</span><br>    <span class="hljs-keyword">return</span> *beg;  <span class="hljs-comment">// return a copy of an element from the range</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><ul><li>当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp;, <span class="hljs-keyword">const</span> T&amp;)</span></span>;<br><span class="hljs-comment">// pf1 points to the instantiation int compare(const int&amp;, const int&amp;)</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*pf1)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;) = compare;<br></code></pre></td></tr></table></figure></li></ul><h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><ul><li><p>从左值引用函数参数推断类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(T&amp;)</span></span>;  <span class="hljs-comment">// argument must be an lvalue</span><br><span class="hljs-comment">// calls to f1 use the referred-to type of the argument as the template parameter type</span><br><span class="hljs-built_in">f1</span>(i);   <span class="hljs-comment">//  i is an int; template parameter T is int</span><br><span class="hljs-built_in">f1</span>(ci);  <span class="hljs-comment">//  ci is a const int; template parameter T is const int</span><br><span class="hljs-built_in">f1</span>(<span class="hljs-number">5</span>);   <span class="hljs-comment">//  error: argument to a &amp; parameter must be an lvalue</span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp;)</span></span>; <span class="hljs-comment">// can take an rvalue</span><br><span class="hljs-comment">// parameter in f2 is const &amp;; const in the argument is irrelevant</span><br><span class="hljs-comment">// in each of these three calls, f2&#x27;s function parameter is inferred as const int&amp;</span><br><span class="hljs-built_in">f2</span>(i);  <span class="hljs-comment">// i is an int; template parameter T is int</span><br><span class="hljs-built_in">f2</span>(ci); <span class="hljs-comment">// ci is a const int, but template parameter T is int</span><br><span class="hljs-built_in">f2</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// a const &amp; parameter can be bound to an rvalue; T is int</span><br></code></pre></td></tr></table></figure></li><li><p>当我们将一个左值传递给函数的右值引用参数，且此右值引用指向模板类型参数（如<code>T&amp;&amp;</code>）时，编译器推断模板类型参数为实参的左值引用类型。</p></li><li>通常我们不能（直接）定义一个引用的引用，但是通过类型别名或通过模板类型参数间接定义是可以的。如果我们间接创建一个引用的引用，则这些引用会形成折叠，即对于一个给定的类型X：<ul><li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>和<code>X&amp;&amp; &amp;</code>都折叠成类型<code>X &amp;</code></li><li><code>X&amp;&amp; &amp;&amp;</code>折叠成<code>X&amp;&amp;</code></li></ul></li></ul><h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解<code>std::move</code></h3><ul><li><p><code>std::move</code>的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(T&amp;&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;typenameremove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>虽然不能隐式地将一个左值转换为右值引用，但我们可以用<code>static_cast</code>显式的将一个左值转换为一个右值引用。</p></li></ul><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><ul><li>通过将一个函数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。</li><li><code>forward</code>必须通过显式模板实参调用，<code>forward</code>返回该显式实参类型的右值引用。即，<code>forward&lt;T&gt;</code>的返回类型是<code>T&amp;&amp;</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt; <span class="hljs-built_in">intermediary</span>(Type &amp;&amp;arg)<br>&#123;<br>    <span class="hljs-built_in">finalFcn</span>(std::forward&lt;Type&gt;(arg));<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><ul><li>当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。</li><li>对一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。</li></ul><h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><ul><li>一个<strong>可变参数模板</strong>（variadic template）就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>（parameter packet）。存在两种参数包：<strong>模板参数包</strong>（template parameter packet），表示零个或多个模板参数；<strong>函数参数包</strong>（function parameter packet），表示零个或多个函数参数。</li><li><p>如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Args is a template parameter pack; rest is a function parameter pack</span><br><span class="hljs-comment">// Args represents zero or more template type parameters</span><br><span class="hljs-comment">// rest represents zero or more function parameters</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T &amp;t, <span class="hljs-keyword">const</span> Args&amp; ... rest)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><code>sizeof ...</code>运算符返回参数包中元素个数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> ... Args&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(Args ... args)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-keyword">sizeof</span>...(Args) &lt;&lt; endl;  <span class="hljs-comment">// number of type parameters</span><br>    cout &lt;&lt; <span class="hljs-keyword">sizeof</span>...(args) &lt;&lt; endl;  <span class="hljs-comment">// number of function parameters</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h3><ul><li><p>可变参数函数通常是递归的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// function to end the recursion and print the last element</span><br><span class="hljs-comment">// this function must be declared before the variadic version of print is defined</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-keyword">const</span> T &amp;t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; t; <span class="hljs-comment">// no separator after the last element in the pack</span><br>&#125;<br><span class="hljs-comment">// this version of print will be called for all but the last element in the pack</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-keyword">const</span> T &amp;t, <span class="hljs-keyword">const</span> Args&amp;... rest)</span></span><br><span class="hljs-function"></span>&#123;<br>    os &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;           <span class="hljs-comment">// print the first argument</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(os, rest...); <span class="hljs-comment">// recursive call; print the other</span><br>arguments<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>非可变参数模板比可变参数模板更特例化。</p></li></ul><h3 id="包括展"><a href="#包括展" class="headerlink" title="包括展"></a>包括展</h3><ul><li>对于一个参数包，除了可以获取其大小外，我们能对它做的唯一的事情就是<strong>扩展</strong>（expand）。当扩展一个包时，需要提供用于每个扩展元素的<strong>模式</strong>（pattern）。拓展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边放一个省略号（…）来触发扩展操作。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function">ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(ostream &amp;os, <span class="hljs-keyword">const</span> T &amp;t, <span class="hljs-keyword">const</span> Args&amp;... rest)</span><span class="hljs-comment">// expand Args</span></span><br><span class="hljs-function"></span>&#123;<br>    os &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(os, rest...);                     <span class="hljs-comment">// expand rest</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><ul><li>一个特例化版本是模板的一个独立的定义，其中一个或多个模板参数被指定为特定的类型。</li><li><p>当我们特例化一个函数模板时，必须为原模板中每个模板参数都提供实参。为了指出我们正在实例化一个模板，应使用关键字<code>template</code>后跟空尖括号对<code>&lt;&gt;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// special version of compare to handle pointers to character arrays</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> &amp;p1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">const</span> &amp;p2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(p1, p2);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当我们定义一个特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。</p></li><li><p>特例化一个模板时，必须在原模板定义所在的命名空间中特例化它。</p></li></ul><h3 id="类模板部分特例化"><a href="#类模板部分特例化" class="headerlink" title="类模板部分特例化"></a>类模板部分特例化</h3><p>标准库中的<code>remove_reference</code>类型是通过一系列的特例化版本实现其功能的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// original, most general template</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remove_reference</span> &#123;</span><br>    <span class="hljs-keyword">typedef</span> T type;<br>&#125;;<br><span class="hljs-comment">// partial specializations that will be used for lvalue and rvalue references</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remove_reference</span>&lt;</span>T&amp;&gt;  <span class="hljs-comment">// lvalue references</span><br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">remove_reference</span>&lt;</span>T&amp;&amp;&gt; <span class="hljs-comment">// rvalue references</span><br>&#123; <span class="hljs-keyword">typedef</span> T type; &#125;;<br></code></pre></td></tr></table></figure></p><p>部分特例化的模板参数列表是原始模板的参数列表的一个子集或是一个特例化版本。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Object-Oriented Programming</title>
    <link href="/2019/10/09/oop/"/>
    <url>/2019/10/09/oop/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><ul><li><p>对于某些函数，基类希望它的派生类各自定义适合自生的版本，此时基类就将这些函数声明成<strong>虚函数</strong>（virtual function）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quote</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">isbn</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span> n)</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>派生类必须在其内部对所有重新定义的虚函数进行声明。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在函数形参列表之后增加一个<code>override</code>关键字。</p></li><li><p><code>print_total</code>是使用引用类型调用<code>net_price</code>函数的，实际传入<code>print_total</code>的对象类型将决定执行<code>net_price</code>的哪个版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// calculate and print the price for the given number of copies, applying any discounts</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">print_total</span><span class="hljs-params">(ostream &amp;os,</span></span><br><span class="hljs-function"><span class="hljs-params">                   <span class="hljs-keyword">const</span> Quote &amp;item, <span class="hljs-keyword">size_t</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// depending on the type of the object bound to the item parameter</span><br>    <span class="hljs-comment">// calls either Quote::net_price or Bulk_quote::net_price</span><br>    <span class="hljs-keyword">double</span> ret = item.<span class="hljs-built_in">net_price</span>(n);<br>    os &lt;&lt; <span class="hljs-string">&quot;ISBN: &quot;</span> &lt;&lt; item.<span class="hljs-built_in">isbn</span>() <span class="hljs-comment">// calls Quote::isbn</span><br>       &lt;&lt; <span class="hljs-string">&quot; # sold: &quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; total due: &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br>     <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">// basic has type Quote; bulk has type Bulk_quote</span><br><span class="hljs-built_in">print_total</span>(cout, basic, <span class="hljs-number">20</span>); <span class="hljs-comment">//  calls Quote version of net_price</span><br><span class="hljs-built_in">print_total</span>(cout, bulk, <span class="hljs-number">20</span>);  <span class="hljs-comment">//  calls Bulk_quote version of net_price</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><ul><li>作为继承关系中根节点的类通常都会定义一个虚析构函数。</li><li>在C++语言中，基类必须将它的两种成员函数区分开：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通常将其定义为<strong>虚函数</strong>（virtual）。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。</li><li>任何构造函数之外的非静态函数都可以是虚函数。关键字<code>virtual</code>只能出现在类内部的声明语句之前而不能用于类外部的函数定义。</li><li><p>如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。</p></li><li><p>成员函数若没有被声明为虚函数，则其解析过程发生在编译时而非运行时。</p></li><li><p>对于某些成员，基类希望它的派生类有权限访问该成员，同时禁止其他用户访问。我们使用<code>protected</code>修饰这样的成员。</p></li></ul><h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><ul><li>派生类使用<strong>类派生列表</strong>（class derivation list）明确指出它是从哪个（哪些）基类继承而来。其中每个基类前面可以有以下三种访问说明符中的一个：<code>public</code>、<code>protected</code>或者<code>private</code>。</li><li>如果一个派生是共有的，则基类的共有成员也是派生类接口的组成部分。并且我们可以将公有派生类型的对象绑定到基类的引用或指针上。</li><li><p>如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似与其他的普通成员，派生类会直接继承其在基类中的版本。</p></li><li><p>派生类可以在它覆盖的函数前使用<code>virtual</code>关键字，但不是一定要这么做。</p></li><li><p>因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的引用或指针绑定到派生类对象的基类部分上。这种转换通常称为<strong>派生类到基类</strong>（derived-to-base）类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Quote item;        <span class="hljs-comment">//  object of base type</span><br>Bulk_quote bulk;   <span class="hljs-comment">//  object of derived type</span><br>Quote *p = &amp;item;  <span class="hljs-comment">//  p points to a Quote object</span><br>p = &amp;bulk;         <span class="hljs-comment">//  p points to the Quote part of bulk</span><br>Quote &amp;r = bulk;   <span class="hljs-comment">//  r bound to the Quote part of bulk</span><br></code></pre></td></tr></table></figure></li><li><p>和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::string&amp; book, <span class="hljs-keyword">double</span> p,<br>           std::<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc) :<br>           <span class="hljs-built_in">Quote</span>(book, p), <span class="hljs-built_in">min_qty</span>(qty), <span class="hljs-built_in">discount</span>(disc) &#123; &#125;<br>    <span class="hljs-comment">// as before</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。</p></li><li><p>派生类可以访问基类中的<code>public</code>和<code>protected</code>成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// if the specified number of items are purchased, use the discounted price</span><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Bulk_quote::net_price</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> cnt)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt &gt;= min_qty)<br>        <span class="hljs-keyword">return</span> cnt * (<span class="hljs-number">1</span> - discount) * price;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> cnt * price;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>派生类的作用域嵌套在基类的作用域之内。</p></li><li><p>如果基类定义了一个<code>static</code>成员，则在整个继承体系中只存在该成员的唯一定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">statmem</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Derived&amp;)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Derived::f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Derived &amp;derived_obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    Base::<span class="hljs-built_in">statmem</span>();    <span class="hljs-comment">// ok: Base defines statmem</span><br>    Derived::<span class="hljs-built_in">statmem</span>(); <span class="hljs-comment">// ok: Derived inherits statmem</span><br>    <span class="hljs-comment">// ok: derived objects can be used to access static from base</span><br>    derived_obj.<span class="hljs-built_in">statmem</span>(); <span class="hljs-comment">// accessed through a Derived object</span><br>    <span class="hljs-built_in">statmem</span>();             <span class="hljs-comment">// accessed through this object</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>派生类的声明中包含类名但不包含它的派生列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Quote; <span class="hljs-comment">// error: derivation list can&#x27;t appear here</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span>;</span>                <span class="hljs-comment">// ok: right way to declare a derived class</span><br></code></pre></td></tr></table></figure></li><li><p>一个类在被用作基类之前，必须以及定义而非仅仅声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quote</span>;</span>   <span class="hljs-comment">// declared but not defined</span><br><span class="hljs-comment">// error: Quote must be defined</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Quote &#123; ... &#125;;<br></code></pre></td></tr></table></figure></li><li><p>C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字final：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoDerived</span> <span class="hljs-keyword">final</span> &#123;</span> <span class="hljs-comment">/*  */</span> &#125;; <span class="hljs-comment">// NoDerived can&#x27;t be a base class</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span> <span class="hljs-comment">/*  */</span> &#125;;<br><span class="hljs-comment">// Last is final; we cannot inherit from Last</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Last</span> <span class="hljs-keyword">final</span> :</span> Base &#123; <span class="hljs-comment">/*  */</span> &#125;; <span class="hljs-comment">// Last can&#x27;t be a base class</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bad</span> :</span> NoDerived &#123; <span class="hljs-comment">/*  */</span> &#125;;   <span class="hljs-comment">// error: NoDerived is final</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bad2</span> :</span> Last &#123; <span class="hljs-comment">/*  */</span> &#125;;       <span class="hljs-comment">// error: Last is final</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><ul><li>可以将基类的指针绑定到派生类对象上。</li><li>和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。</li><li>当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的<strong>静态类型</strong>（static type）与该表达式表示对象的<strong>动态类型</strong>（dynamic type）区分开来。表达式的静态类型在编译时是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型在运行时才可知。</li><li>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</li><li><p>因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Quote base;<br>Bulk_quote* bulkP = &amp;base;  <span class="hljs-comment">// error: can&#x27;t convert base to derived</span><br>Bulk_quote&amp; bulkRef = base; <span class="hljs-comment">// error: can&#x27;t convert base to derived</span><br></code></pre></td></tr></table></figure></li><li><p>派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。</p></li></ul><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul><li>因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有的虚函数都必须有定义。</li><li><p>动态绑定只有当我们通过指针或引用调用虚函数时才会发生，当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Quote <span class="hljs-title">base</span><span class="hljs-params">(<span class="hljs-string">&quot;0-201-82470-1&quot;</span>, <span class="hljs-number">50</span>)</span></span>;<br><span class="hljs-built_in">print_total</span>(cout, base, <span class="hljs-number">10</span>);    <span class="hljs-comment">// calls Quote::net_price</span><br><span class="hljs-function">Bulk_quote <span class="hljs-title">derived</span><span class="hljs-params">(<span class="hljs-string">&quot;0-201-82470-1&quot;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">5</span>, <span class="hljs-number">.19</span>)</span></span>;<br><span class="hljs-built_in">print_total</span>(cout, derived, <span class="hljs-number">10</span>); <span class="hljs-comment">// calls Bulk_quote::net_price</span><br><br>base = derived;         <span class="hljs-comment">// copies the Quote part of derived into base</span><br>base.<span class="hljs-built_in">net_price</span>(<span class="hljs-number">20</span>);     <span class="hljs-comment">// calls Quote::net_price</span><br></code></pre></td></tr></table></figure></li><li><p>当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</p></li><li>一旦某个函数被声明成虚函数，则在所有的派生类中他都是虚函数。</li><li>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。</li><li><p>如果我们使用<code>override</code>标记了某个函数，但该函数没有覆盖已存在的虚函数，此时编译器将报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D1</span> :</span> B &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// ok: f1 matches f1 in the base</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">override</span></span>; <span class="hljs-comment">// error: B has no f2(int) function</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;    <span class="hljs-comment">// error: f3 not virtual</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;    <span class="hljs-comment">// error: B doesn&#x27;t have a function named f4</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>可以将某个函数指定为<code>final</code>，被定义为<code>final</code>的函数不能被它的派生类覆盖：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D2</span> :</span> B &#123;<br>    <span class="hljs-comment">// inherits f2() and f3() from B and overrides f1(int)</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">final</span></span>; <span class="hljs-comment">// subsequent classes can&#x27;t override f1(int)</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">D3</span> :</span> D2 &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>;          <span class="hljs-comment">// ok: overrides f2 inherited from the indirect base, B</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// error: D2 declared f2 as final</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。也就是说，若通过基类的引用或者指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p></li><li>使用作用域运算符可以强制执行虚函数的某个特定版本：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//  calls the version from the base class regardless of the dynamic type of baseP</span><br><span class="hljs-keyword">double</span> undiscounted = baseP-&gt;Quote::<span class="hljs-built_in">net_price</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><ul><li><p>可以将函数定义为<strong>纯虚</strong>（pure virtual）函数，表面该函数是没有实际意义的。纯虚函数无需定义，通过在函数体的位置书写<code>=0</code>可以将一个虚函数说明为纯虚函数。其中，<code>=0</code>只能出现在类内部的虚函数声明语句处：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// class to hold the discount rate and quantity</span><br><span class="hljs-comment">// derived classes will implement pricing strategies using these data</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Disc_quote</span> :</span> <span class="hljs-keyword">public</span> Quote &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Disc_quote</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Disc_quote</span>(<span class="hljs-keyword">const</span> std::string&amp; book, <span class="hljs-keyword">double</span> price,<br>              std::<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc):<br>                 <span class="hljs-built_in">Quote</span>(book, price),<br>                 <span class="hljs-built_in">quantity</span>(qty), <span class="hljs-built_in">discount</span>(disc) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">protected</span>:<br>    std::<span class="hljs-keyword">size_t</span> quantity = <span class="hljs-number">0</span>; <span class="hljs-comment">//  purchase size for the discount to apply</span><br>    <span class="hljs-keyword">double</span> discount = <span class="hljs-number">0.0</span>;    <span class="hljs-comment">//  fractional discount to apply</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>可以为纯虚函数提供定义，不过函数体必须定义在类的外部，也就是说，不能在类的内部为一个<code>=0</code>的函数提供函数体。</p></li><li>含有（或者未经覆盖直接继承）纯虚函数的类是<strong>抽象基类</strong>（abstract base class）。不能直接创建一个抽象基类的对象。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Disc_quote declares pure virtual functions, which Bulk_quote will override</span><br>Disc_quote discounted; <span class="hljs-comment">// error: can&#x27;t define a Disc_quote object</span><br>Bulk_quote bulk;       <span class="hljs-comment">// ok: Bulk_quote has no pure virtual functions</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><ul><li>一个类使用<code>protected</code>关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。</li><li><p>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> prot_mem;     <span class="hljs-comment">// protected member</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sneaky</span> :</span> <span class="hljs-keyword">public</span> Base  &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky&amp;)</span></span>;  <span class="hljs-comment">// can access Sneaky::prot_mem</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base&amp;)</span></span>;    <span class="hljs-comment">// can&#x27;t access Base::prot_mem</span><br>    <span class="hljs-keyword">int</span> j;                          <span class="hljs-comment">// j is private by default</span><br>&#125;;<br><span class="hljs-comment">// ok: clobber can access the private and protected members in Sneaky objects</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-comment">// error: clobber can&#x27;t access the protected members in Base</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clobber</span><span class="hljs-params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="hljs-number">0</span>; &#125;<br></code></pre></td></tr></table></figure></li><li><p>派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没有影响，对基类成员的访问权限只与基类中的访问说明符有关。</p></li><li><p>派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pub_mem</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// public member</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">int</span> prot_mem;     <span class="hljs-comment">// protected member</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">char</span> priv_mem;    <span class="hljs-comment">// private member</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pub_Derv</span> :</span> <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-comment">// ok: derived classes can access protected members</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> prot_mem; &#125;<br>    <span class="hljs-comment">// error: private members are inaccessible to derived classes</span><br>    <span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> priv_mem; &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Priv_Derv</span> :</span> <span class="hljs-keyword">private</span> Base &#123;<br>    <span class="hljs-comment">// private derivation doesn&#x27;t affect access in the derived class</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> prot_mem; &#125;<br>&#125;;<br><br>Pub_Derv d1;   <span class="hljs-comment">//  members inherited from Base are public</span><br>Priv_Derv d2;  <span class="hljs-comment">//  members inherited from Base are private</span><br>d1.<span class="hljs-built_in">pub_mem</span>();  <span class="hljs-comment">//  ok: pub_mem is public in the derived class</span><br>d2.<span class="hljs-built_in">pub_mem</span>();  <span class="hljs-comment">//  error: pub_mem is private in the derived class</span><br></code></pre></td></tr></table></figure></li><li><p>派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。</p></li><li><p>对于代码中的某个给定节点来说，如果基类的共有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</p></li><li><p>就像友元关系不能传递一样，友元关系同样也不能继承。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br>    <span class="hljs-comment">// added friend declaration; other members as before</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal</span>;</span> <span class="hljs-comment">// Pal has no access to classes derived from Base</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pal</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(Base b)</span> </span>&#123; <span class="hljs-keyword">return</span> b.prot_mem; &#125; <span class="hljs-comment">// ok: Pal is a friend of Base</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f2</span><span class="hljs-params">(Sneaky s)</span> </span>&#123; <span class="hljs-keyword">return</span> s.j; &#125; <span class="hljs-comment">// error: Pal not friend of Sneaky</span><br>    <span class="hljs-comment">// access to a base class is controlled by the base class, even inside a derived object</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f3</span><span class="hljs-params">(Sneaky s)</span> </span>&#123; <span class="hljs-keyword">return</span> s.prot_mem; &#125; <span class="hljs-comment">// ok: Pal is a friend</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>通过在类的内部使用<code>using</code>声明语句，可以将该类的直接或间接基类中的任何可访问成员标记出来，改变这些成员的可访问性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::<span class="hljs-keyword">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> n; &#125;<br><span class="hljs-keyword">protected</span>:<br>    std::<span class="hljs-keyword">size_t</span> n;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">private</span> Base &#123;    <span class="hljs-comment">//  note: private inheritance</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// maintain access levels for members related to the size of the object</span><br>    <span class="hljs-keyword">using</span> Base::size;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">using</span> Base::n;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>默认情况下，使用<code>class</code>关键字定义的派生类是私有继承的；而使用<code>struct</code>关键字定义的派生类是共有继承的。</p></li></ul><h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><ul><li>如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。</li></ul><h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><ul><li>通常如果一个类需要析构函数，那么它同样需要拷贝和赋值操作。但一个基类总是需要虚析构函数，若该析构函数为了成为虚函数而令内容为空，则无法由此推断该基类还需要赋值运算符或拷贝构造函数。</li></ul><h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><ul><li>在实际中，如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不对定义相应的操作。</li></ul><h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><ul><li>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</li><li>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。</li><li><p>与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Base::operator=(const Base&amp;) is not invoked automatically</span><br>D &amp;D::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> D &amp;rhs)<br>&#123;<br>    Base::<span class="hljs-keyword">operator</span>=(rhs); <span class="hljs-comment">// assigns the base part</span><br>    <span class="hljs-comment">// assign the members in the derived class, as usual,</span><br>    <span class="hljs-comment">// handling self-assignment and freeing existing resources as appropriate</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在析构函数体执行完成后，对象的成员会被隐式销毁；类似的，对象的基类部分也是隐式销毁的。因此，与构造函数及赋值运算符不同，派生类析构函数只负责由派生类自己分配的资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>:</span> <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Base::~Base invoked automatically</span><br>    ~<span class="hljs-built_in">D</span>() &#123; <span class="hljs-comment">/* do what it takes to clean up derived members   */</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着集继承体系的反方向直至最后。</p></li><li>如果构造函数或者析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</li></ul><h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><ul><li><p>通常，<code>using</code>声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，<code>using</code>声明语句将令编译器产生代码。</p></li><li><p>在以下<code>Bulk_quote</code>类中，继承的构造函数与以下函数等价：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bulk_quote</span> :</span> <span class="hljs-keyword">public</span> Disc_quote &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Disc_quote::Disc_quote; <span class="hljs-comment">// inherit Disc_quote&#x27;s constructors</span><br>    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">net_price</span><span class="hljs-params">(std::<span class="hljs-keyword">size_t</span>)</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br><br><span class="hljs-built_in">Bulk_quote</span>(<span class="hljs-keyword">const</span> std::string&amp; book, <span class="hljs-keyword">double</span> price,<br>          std::<span class="hljs-keyword">size_t</span> qty, <span class="hljs-keyword">double</span> disc):<br>      <span class="hljs-built_in">Disc_quote</span>(book, price, qty, disc) &#123; &#125;<br></code></pre></td></tr></table></figure></li><li><p>和普通成员的<code>using</code>声明不一样，一个构造函数的<code>using</code>声明不会改变该构造函数的访问级别。不管<code>using</code>声明出现在哪，派生类从基类继承的构造函数与基类中的构造函数具有相同的访问级别。</p></li><li>如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。</li><li>默认、拷贝和移动构造函数不会被继承。</li></ul><h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><ul><li>当派生类对象被赋值给基类对象时，其中派生类部分将被“切掉”。</li><li><p>当我们希望在容器中存放具有继承关系的对象时，我们通常存放的是基类的指针（更好的选择是智能指针）。</p></li><li><p>当我们令一个类公有地继承另一个类时，派生类与基类的关系是“是一种（Is A）”。在设计良好的类体系中，公有派生类的对象应该可以用在任何需要基类对象的地方。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Overloaded Operations and Conversions</title>
    <link href="/2019/09/26/OverloadedOperationsAndConversions/"/>
    <url>/2019/09/26/OverloadedOperationsAndConversions/</url>
    
    <content type="html"><![CDATA[<h1 id="重载运算符与类型转换"><a href="#重载运算符与类型转换" class="headerlink" title="重载运算符与类型转换"></a>重载运算符与类型转换</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>除了重载的函数调用运算符<code>operator()</code>外，重载的运算符不能有默认实参。</li><li>如果一个运算符函数是成员函数，第一个（左侧）操作数绑定到隐式的<code>this</code>指针上。</li><li><p>对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// error: cannot redefine the built-in operator for ints</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>);<br></code></pre></td></tr></table></figure></li><li><p>可被重载与不可被重载的运算符：</p></li></ul><div align=center> <img src="/2019/09/26/OverloadedOperationsAndConversions/14-1.png" class=""> </div><ul><li>对于既可以是一元又可以是二元的运算符（+，-，*和&amp;），定义的运算符取决于参数的数量。</li><li><p>重载的运算符具有和内置运算符相同的优先级和结合律。</p></li><li><p>可以像调用普通函数一样调用重载运算符函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// equivalent calls to a nonmember operator function</span><br>data1 + data2;           <span class="hljs-comment">// normal expression</span><br><span class="hljs-keyword">operator</span>+(data1, data2); <span class="hljs-comment">// equivalent function call</span><br></code></pre></td></tr></table></figure></li><li><p>部分运算符保证了运算对象求值的顺序，但使用重载的运算符函数实际上是函数调用，不能保证运算对象的求值顺序。</p></li></ul><h2 id="输入和输出运算符"><a href="#输入和输出运算符" class="headerlink" title="输入和输出运算符"></a>输入和输出运算符</h2><ul><li>输入运算符必须处理输入出错的情况，但输出运算符不需要。</li></ul><h2 id="算术与关系运算符"><a href="#算术与关系运算符" class="headerlink" title="算术与关系运算符"></a>算术与关系运算符</h2><ul><li>当一个类同时重载了算术运算符和对应的复合赋值运算符时，使用复合赋值运算符来定义算术运算符效率更高：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// assumes that both objects refer to the same book</span><br>Sales_data<br><span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Sales_data &amp;lhs, <span class="hljs-keyword">const</span> Sales_data &amp;rhs)<br>&#123;<br>    Sales_data sum = lhs;  <span class="hljs-comment">// copy data members from lhs into sum</span><br>    sum += rhs;             <span class="hljs-comment">// add rhs into sum</span><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul><li>赋值运算符可以被重载，无论参数类型是什么，赋值运算符都应该被定义为成员函数。</li></ul><h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><h2 id="递增与递减运算符"><a href="#递增与递减运算符" class="headerlink" title="递增与递减运算符"></a>递增与递减运算符</h2><ul><li>后置的递增与递减运算符接收一个额外（不被使用）的<code>int</code>类型参数，用于区分前置版本：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrBlobPtr</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// increment and decrement</span><br>    StrBlobPtr&amp; <span class="hljs-keyword">operator</span>++();       <span class="hljs-comment">// prefix operators</span><br>    StrBlobPtr&amp; <span class="hljs-keyword">operator</span>--();<br>    <br>    StrBlobPtr <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>);    <span class="hljs-comment">// postfix operators</span><br>    StrBlobPtr <span class="hljs-keyword">operator</span>--(<span class="hljs-keyword">int</span>);<br>    <span class="hljs-comment">// other members as before</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><ul><li><p>根据<code>point</code>类型的不同，<code>point-&gt;mem</code>分别等价于</p><ul><li><code>(*point).mem;               // (1) point is a built-in pointer type</code></li><li><code>point.operator-&gt;()-&gt;mem;    // (2) point is an object of class type</code></li></ul><p>如果<code>point</code>是指针，<code>point-&gt;mem</code>等价于（1）；如果<code>point</code>是定义了<code>operator-&gt;()</code>的类的一个对象，则使用<code>point.operator-&gt;()</code>的结果来获取<code>mem</code>，若该结果是一个指针，则执行（1），若该结果为定义了<code>operator-&gt;()</code>的类的一个对象，则重复调用当前步骤。</p></li></ul><h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><ul><li>函数调用运算符必须是成员函数。一个类可以定义多个版本的函数调用运算符，它们之间必须在参数数量或类型上有所区别。<h3 id="Lambda表达式是函数对象"><a href="#Lambda表达式是函数对象" class="headerlink" title="Lambda表达式是函数对象"></a>Lambda表达式是函数对象</h3></li></ul><h3 id="标准库函数对象"><a href="#标准库函数对象" class="headerlink" title="标准库函数对象"></a>标准库函数对象</h3><ul><li>以下类型定义在<code>functional</code>头文件中</li></ul><div align=center> <img src="/2019/09/26/OverloadedOperationsAndConversions/14-2.png" class=""> </div><ul><li>内置关系运算符<code>&lt;</code>对于指针类型是未定义的，但标准库提供的函数对象保证了对指针类型是正确定义的：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;string *&gt; nameTable;  <span class="hljs-comment">// vector of pointers</span><br><span class="hljs-comment">// error: the pointers in nameTable are unrelated, so &lt; is undefined</span><br><span class="hljs-built_in">sort</span>(nameTable.<span class="hljs-built_in">begin</span>(), nameTable.<span class="hljs-built_in">end</span>(), [](string *a, string *b) &#123; <span class="hljs-keyword">return</span> a &lt; b; &#125;);<br><span class="hljs-comment">// ok: library guarantees that less on pointer types is well defined</span><br><span class="hljs-built_in">sort</span>(nameTable.<span class="hljs-built_in">begin</span>(), nameTable.<span class="hljs-built_in">end</span>(), less&lt;string*&gt;());<br></code></pre></td></tr></table></figure></li></ul><h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与<code>function</code></h3><ul><li><p>调用形式（call signature）指明了调用返回的类型以及传递给调用的实参类型。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)<br></code></pre></td></tr></table></figure></li><li><p>具有相同调用形式的可调用对象可能具有不同的类型，标准库<code>function</code>类型可以存放具有相同调用形式的可调用对象。以下是<code>function</code>的操作：</p><div align=center> <img src="/2019/09/26/OverloadedOperationsAndConversions/14-3.png" class=""> </div></li></ul><h2 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h2><ul><li>转换构造函数和类型转换运算符共同定义了<strong>类类型转换</strong>（class-type conversions），这样的转换有时也被称作<strong>用户定义的类型转换</strong>（user-defined conversions）。</li><li><p><strong>类型转换运算符</strong>（conversion operator）是类的一种特殊成员函数，它的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>编译器一般不会将声明为<code>explicit</code>的类型转换运算符用于隐式类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallInt</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// the compiler won&#x27;t automatically apply this conversion</span><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> val; &#125;<br>    <span class="hljs-comment">// other members as before</span><br>&#125;;<br>SmallInt si = <span class="hljs-number">3</span>;  <span class="hljs-comment">// ok: the SmallInt constructor is not explicit</span><br>si + <span class="hljs-number">3</span>; <span class="hljs-comment">// error: implicit is conversion required, but operator int is explicit</span><br><span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(si) + <span class="hljs-number">3</span>; <span class="hljs-comment">// ok: explicitly request the conversion</span><br></code></pre></td></tr></table></figure></li><li><p>有一个例外，在表达式用于条件判断时，声明为<code>explicit</code>的类型转换会隐式地执行。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Copy Control</title>
    <link href="/2019/09/23/CopyControl/"/>
    <url>/2019/09/23/CopyControl/</url>
    
    <content type="html"><![CDATA[<h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><p>当我们定义一个类时，我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：<strong>拷贝构造函数</strong>（copy constructor）、<strong>拷贝赋值运算符</strong>（copy assignment operator）、<strong>移动构造函数</strong>（move constructor）、<strong>移动赋值运算符</strong>（move assignment operator）和<strong>析构函数</strong>（destructor）。</p><h2 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><ul><li><p>如果一个构造函数的第一个参数是对自身类型的引用，并且其他参数都有默认值，则此构造函数是拷贝构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>();            <span class="hljs-comment">// default constructor</span><br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">const</span> Foo&amp;);  <span class="hljs-comment">// copy constructor</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。</p></li><li>合成拷贝构造函数依次将每个非<code>static</code>成员拷贝到正在创建的对象中。每个成员的类型决定了它如何拷贝：对类类型的成员，使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。</li><li>虽然我们不能直接拷贝一个数组，但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。</li><li>拷贝初始化不仅在使用<code>=</code>定义变量时发生，在下列情况下也会发生：<ul><li>将一个对象作为实参传递给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li></ul></li></ul><h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><ul><li>如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的<code>this</code>参数。对于二元运算符，其右侧对象作为显式参数传递。</li></ul><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul><li>由于析构函数没有参数，因此它不能被重载。对一个给定的类，只会有一个析构函数。</li><li>在析构函数中，首先执行函数体，然后销毁成员。成员按初始化的逆序销毁。</li><li>销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，所以销毁内置类型成员什么都不需要做。</li></ul><h3 id="三-五法则"><a href="#三-五法则" class="headerlink" title="三/五法则"></a>三/五法则</h3><ul><li>如果一个类需要析构函数，那么它几乎肯定也需要拷贝构造函数和拷贝赋值运算符。</li><li>如果一个类需要拷贝构造函数，那么它几乎一定需要拷贝赋值运算符，反之亦然。</li></ul><h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用<code>=default</code></h3><ul><li>当在类内使用<code>=default</code>修饰成员的声明时，合成的函数将隐式地声明为内联的。</li></ul><h3 id="阻值拷贝"><a href="#阻值拷贝" class="headerlink" title="阻值拷贝"></a>阻值拷贝</h3><ul><li><p><code>=delete</code>必须出现在函数第一次声明的时候，并且可以对任何函数指定<code>=delete</code>。</p></li><li><p>如果一个类成员的析构函数是删除的，则该成员无法被销毁；而如果一个成员无法被销毁，则该对象整体也无法被销毁。</p></li><li>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则类的合成拷贝控制成员将被定义为删除的。</li></ul><h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><h3 id="行为像值的类"><a href="#行为像值的类" class="headerlink" title="行为像值的类"></a>行为像值的类</h3><ul><li>编写赋值运算符时，需要记住两点：<ul><li>赋值运算符必须在一个对象赋值给他本身时正确工作。</li><li>大多数赋值运算组合了析构函数和构造函数的工作。</li></ul></li></ul><h3 id="行为像指针的类"><a href="#行为像指针的类" class="headerlink" title="行为像指针的类"></a>行为像指针的类</h3><ul><li>使用动态内存进行引用计数。</li></ul><h2 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h2><ul><li>如果存在类型特定的<code>swap</code>版本，其匹配优先程度会优于<code>std</code>中定义的版本。</li></ul><h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><ul><li>移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象。</li><li>调用<code>move</code>的返回结果会令<code>construct</code>使用<code>string</code>的移动构造函数。</li><li>对一个对象调用<code>move</code>之后，我们无法知道该对象中保存的值，但是可以保证该对象的构造函数可以正确地执行。</li></ul><h2 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h2><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><ul><li><strong>右值引用</strong>（rvalue reference）是必须绑定到右值的引用，通过<code>&amp;&amp;</code>而不是<code>&amp;</code>来获得右值引用。</li><li>左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时变量。</li><li><p>变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。</p></li><li><p><code>move</code>函数返回给定对象的右值引用。</p></li><li><p>应该直接调用<code>std::move</code>而不是<code>move</code>。</p></li></ul><h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><ul><li><p>一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。</p></li><li><p>不会抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code>。</p></li><li><p>移动操作必须保证移动源对象仍是有效的；一般来说对象有效是指可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。例如，在移动一个<code>string</code>或者其他容器对象后，该移后源对象仍然是有效的，我们可以对它执行<code>empty</code>、<code>size</code>等操作，但结果无法得到保证。</p></li><li><p>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。</p></li><li>只有当一个类没有定义任任何自己版本的拷贝控制成员，且它的所有数据成员都可以移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。</li><li>“何时将合成的移动操作定义为删除的函数”遵循与“定义删除的合成拷贝操作“类似的原则。<ul><li>与拷贝构造函数不同的，移动构造函数被定义为删除函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。</li><li>其他条件与拷贝操作类似。</li></ul></li><li>定义了一个移动构造函数或者移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员默认地被定义为删除的。</li><li>如果一个类既有移动构造函数，也有拷贝构造函数，编译器将使用普通的函数匹配规则来确定使用哪个构造函数。</li><li><p>如果一个类没有移动构造函数，函数匹配保证该类型的对象会被拷贝，即使调用了<code>move</code>也是如此：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-keyword">const</span> Foo&amp;); <span class="hljs-comment">// copy constructor</span><br>    <span class="hljs-comment">// other members, but Foo does not define a move constructor</span><br>&#125;;<br>Foo x;<br><span class="hljs-function">Foo <span class="hljs-title">y</span><span class="hljs-params">(x)</span></span>;            <span class="hljs-comment">// copy constructor; x is an lvalue</span><br><span class="hljs-function">Foo <span class="hljs-title">z</span><span class="hljs-params">(std::move(x))</span></span>; <span class="hljs-comment">// copy constructor, because there is no move constructor</span><br></code></pre></td></tr></table></figure></li><li><p>对<strong>移动迭代器</strong>（move iterator）进行解引用得到的是右值引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">StrVec::reallocate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// allocate space for twice as many elements as the current size</span><br>    <span class="hljs-keyword">auto</span> newcapacity = <span class="hljs-built_in">size</span>() ? <span class="hljs-number">2</span> * <span class="hljs-built_in">size</span>() : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">auto</span> first = alloc.<span class="hljs-built_in">allocate</span>(newcapacity);<br>    <span class="hljs-comment">// move the elements</span><br>    <span class="hljs-keyword">auto</span> last = <span class="hljs-built_in">uninitialized_copy</span>(<span class="hljs-built_in">make_move_iterator</span>(<span class="hljs-built_in">begin</span>()), <br>                                   <span class="hljs-built_in">make_move_iterator</span>(<span class="hljs-built_in">end</span>()), first);<br>    <span class="hljs-built_in">free</span>(); <span class="hljs-comment">// free the old space</span><br>    elements = first; <span class="hljs-comment">// update the pointers</span><br>    first_free = last;<br>    cap = elements + newcapacity;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="右值引用与成员函数"><a href="#右值引用与成员函数" class="headerlink" title="右值引用与成员函数"></a>右值引用与成员函数</h3><ul><li><p>区分移动和拷贝的重载函数通常有一个版本接受一个<code>const T&amp;</code>，而另一个版本接受一个<code>T&amp;&amp;</code>。</p></li><li><p>通常，无论对象是左值还是右值，我们都可以调用它的成员函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s1 = <span class="hljs-string">&quot;a value&quot;</span>, s2 = <span class="hljs-string">&quot;another&quot;</span>;<br><span class="hljs-keyword">auto</span> n = (s1 + s2).<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br></code></pre></td></tr></table></figure></li><li><p>指定<code>this</code>的左值/右值属性的方式与定义<code>const</code>成员函数相同，即在参数列表后放置一个<strong>引用限定符</strong>（reference qualifier）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    Foo &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Foo&amp;) &amp;; <span class="hljs-comment">// may assign only to modifiable lvalues</span><br>    <span class="hljs-comment">// other members of Foo</span><br>&#125;;<br>Foo &amp;Foo::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Foo &amp;rhs) &amp;<br>&#123;<br>    <span class="hljs-comment">// do whatever is needed to assign rhs to this object</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>引用限定符可以是<code>&amp;</code>或者<code>&amp;&amp;</code>，分别指出<code>this</code>指向一个左值或右值。</p></li><li><p>一个函数可以同时用<code>const</code>和引用限定，引用限定符必须跟随在<code>const</code>限定符之后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Foo <span class="hljs-title">someMem</span><span class="hljs-params">()</span> &amp; <span class="hljs-keyword">const</span></span>;    <span class="hljs-comment">// error: const qualifier must come first</span><br>    <span class="hljs-function">Foo <span class="hljs-title">anotherMem</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp;</span>; <span class="hljs-comment">// ok: const qualifier comes first</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>可以根据引用限定符对函数进行重载：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> &amp;&amp;</span>; <span class="hljs-comment">// may run on modifiable rvalues</span><br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp;</span>; <span class="hljs-comment">// may run on any kind of Foo</span><br>    <span class="hljs-comment">// other members of Foo</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; data;<br>&#125;;<br><span class="hljs-comment">// this object is an rvalue, so we can sort in place</span><br><span class="hljs-function">Foo <span class="hljs-title">Foo::sorted</span><span class="hljs-params">()</span> &amp;&amp;</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>    <span class="hljs-comment">// this object is either const or it is an lvalue; either way we can&#x27;t sort in place</span><br><span class="hljs-function">Foo <span class="hljs-title">Foo::sorted</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> &amp; </span>&#123;<br>    <span class="hljs-function">Foo <span class="hljs-title">ret</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>; <span class="hljs-comment">// make a copy</span><br>    <span class="hljs-built_in">sort</span>(ret.data.<span class="hljs-built_in">begin</span>(), ret.data.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// sort the copy</span><br>    <span class="hljs-keyword">return</span> ret; <span class="hljs-comment">// return the copy</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有的函数都加上引用限定符，或者所有的都不加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> &amp;&amp;</span>;<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// error: must have reference qualifier</span><br>    <span class="hljs-comment">// Comp is type alias for the function type (see § 6.7 (p. 249))</span><br>    <span class="hljs-comment">// that can be used to compare int values</span><br>    <span class="hljs-keyword">using</span> Comp = <span class="hljs-built_in"><span class="hljs-keyword">bool</span></span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>&amp;);<br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">(Comp*)</span></span>; <span class="hljs-comment">// ok: different parameter list</span><br>    <span class="hljs-function">Foo <span class="hljs-title">sorted</span><span class="hljs-params">(Comp*)</span> <span class="hljs-keyword">const</span></span>; <span class="hljs-comment">// ok: neither version is reference qualified</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic Memory</title>
    <link href="/2019/09/16/DynamicMemory/"/>
    <url>/2019/09/16/DynamicMemory/</url>
    
    <content type="html"><![CDATA[<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><ul><li>静态内存用于保存局部<code>static</code>对象、类的<code>static</code>成员以及定义在任何函数之外的变量。栈内存用于保存定义在函数内的非<code>static</code>变量。</li><li>除了静态内存与栈内存，每个程序还拥有一个内存池，这部分内存被称为<strong>自由空间</strong>（free store）或<strong>堆</strong>（heap）。</li></ul><h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><ul><li>在C++中，动态内存的管理通过 一对运算符完成：<code>new</code>，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；<code>delete</code>，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</li><li>新标准库提供了两种<strong>智能指针</strong>（smart pointer）类型来管理动态对象：<code>shared_ptr</code>允许多个指针指向同一个对象；<code>unique_ptr</code>则“独占”所指向的对象。标准库还定义了一个名为<code>weak_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象。</li></ul><h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a><code>shared_ptr</code>类</h3><ul><li><p>默认初始化的智能指针保存着一个空指针。</p></li><li><p><code>shared_ptr</code>和<code>unique_ptr</code>都支持的操作</p><div align=center> <img src="/2019/09/16/DynamicMemory/12-1.png" class=""> </div></li><li><p><code>shared_ptr</code>独有的操作</p><div align=center> <img src="/2019/09/16/DynamicMemory/12-2.png" class=""> </div></li><li><p>一旦一个<code>shared_ptr</code>的计数器变为0，它将自动释放自己所管理的对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> r = make_shared&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-number">42</span>); <span class="hljs-comment">// int to which r points has one user</span><br>r = q; <span class="hljs-comment">// assign to r, making it point to a different address</span><br>       <span class="hljs-comment">// increase the use count for the object to which q points</span><br>       <span class="hljs-comment">// reduce the use count of the object to which r had pointed</span><br>       <span class="hljs-comment">// the object r had pointed to has no users; that object is automatically freed</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><ul><li>运算符<code>new</code>分配内存，<code>delete</code>释放<code>new</code>分配的内存。</li><li><p>默认情况下，动态分配的对象是默认初始化的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string *ps = <span class="hljs-keyword">new</span> string; <span class="hljs-comment">// initialized to empty string</span><br><span class="hljs-keyword">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>; <span class="hljs-comment">// pi points to an uninitialized int</span><br></code></pre></td></tr></table></figure></li><li><p>可以使用直接初始化的方式初始化一个动态分配的对象，可以使用传统的构造方式，也可以使用列表初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *pi = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">1024</span>); <span class="hljs-comment">// object to which pi points has value 1024</span><br>string *ps = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;9&#x27;</span>); <span class="hljs-comment">// *ps is &quot;9999999999&quot;</span><br><span class="hljs-comment">// vector with ten elements with values from 0 to 9</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; *pv = <span class="hljs-keyword">new</span> vector&lt;<span class="hljs-keyword">int</span>&gt;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>由于编译器使用初始值类型来推断需要分配内存的类型，只有当括号中仅有单一初始化器时才可以使用<code>auto</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">auto</span></span>(obj); <span class="hljs-comment">// p points to an object of the type of obj</span><br><span class="hljs-comment">// that object is initialized from obj</span><br><span class="hljs-keyword">auto</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">auto</span>&#123;a,b,c&#125;; <span class="hljs-comment">// error: must use parentheses for the initializer</span><br></code></pre></td></tr></table></figure></li><li><p>类似其他<code>const</code>对象，动态分配的<code>const</code>对象必须进行初始化。</p></li><li>若<code>new</code>不能分配所要求的内存空间，它会抛出一个类型为<code>bad_alloc</code>的异常，可以改变<code>new</code>的使用方式阻止其抛出异常：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// if allocation fails, new returns a null pointer</span><br><span class="hljs-keyword">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>; <span class="hljs-comment">// if allocation fails, new throws std::bad_alloc</span><br><span class="hljs-keyword">int</span> *p2 = <span class="hljs-built_in"><span class="hljs-keyword">new</span></span> (nothrow) <span class="hljs-keyword">int</span>; <span class="hljs-comment">// if allocation fails, new returns a null pointer</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a><code>shared_ptr</code>和<code>new</code>结合使用</h3><ul><li><p>定义和改变<code>shared_ptr</code>的其他方法</p><div align=center> <img src="/2019/09/16/DynamicMemory/12-3.png" class=""> </div></li><li><p>接受指针参数的智能指针构造函数是<code>explicit</code>的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">1024</span>); <span class="hljs-comment">// error: must use direct initialization</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">1024</span>))</span></span>; <span class="hljs-comment">// ok: uses direct initialization</span><br></code></pre></td></tr></table></figure></li><li><p>默认情况下，智能指针使用<code>delete</code>释放与之关联的对象。</p></li><li>当将一个<code>shared_ptr</code>绑定到一个普通指针时，我们就将内存的管理责任交给了这个<code>shared_ptr</code>。一旦这样做了，我们就不应该再使用内置指针来访问<code>shared_ptr</code>所指向的内存了。</li><li>虽然编译器不会给出报错信息，但将另一个智能指针也绑定到<code>get</code>返回的指针上是错误的。</li></ul><h3 id="智能指针与异常"><a href="#智能指针与异常" class="headerlink" title="智能指针与异常"></a>智能指针与异常</h3><ul><li>如果一个异常发生在<code>new</code>与<code>delete</code>之间，并且异常没有在<code>f</code>中捕获，那么内存将永远不会被释放：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> *ip = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// dynamically allocate a new object</span><br>    <span class="hljs-comment">// code that throws an exception that is not caught inside f</span><br>    <span class="hljs-keyword">delete</span> ip; <span class="hljs-comment">// free the memory before exiting</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><code>unique_ptr</code></h3><ul><li>不同于<code>shared_ptr</code>，同时只能有一个<code>unique_ptr</code>指向一个给定对象。</li><li><p><code>unique_ptr</code>操作</p><div align=center> <img src="/2019/09/16/DynamicMemory/12-4.png" class=""> </div></li><li><p>与<code>shared_ptr</code>不同，没有类似<code>make_shared</code>的标准库函数返回一个<code>unique_ptr</code>。当我们定义一个<code>unique_ptr</code>时，需要将其绑定到一个<code>new</code>返回的指针上。类似<code>shared_ptr</code>，初始化<code>unique_ptr</code>必须采用直接初始化形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">unique_ptr&lt;<span class="hljs-keyword">double</span>&gt; p1; <span class="hljs-comment">// unique_ptr that can point at a double</span><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(<span class="hljs-number">42</span>))</span></span>; <span class="hljs-comment">// p2 points to int with value 42</span><br></code></pre></td></tr></table></figure></li><li><p>不能拷贝<code>unique_ptr</code>的规则有一个例外：我们拷贝或赋值一个将要被销毁的<code>unique_ptr</code>，最常见的例子是从函数返回一个<code>unique_ptr</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-comment">// ok: explicitly create a unique_ptr&lt;int&gt; from int*</span><br>    <span class="hljs-keyword">return</span> unique_ptr&lt;<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(p));<br>&#125;<br><br><span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-function">unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> (p))</span></span>;<br>    <span class="hljs-comment">// . . .</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a><code>weak_ptr</code></h3><div align=center> <img src="/2019/09/16/DynamicMemory/12-5.png" class=""> </div><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><ul><li>分配了动态数组的类必须定义自己版本的操作，在拷贝、复制及销毁对象时管理所关联的内存。</li></ul><h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a><code>new</code>和数组</h3><ul><li>使用<code>new</code>分配一个数组时，获得的不是数组类型的对象，而是指向数组元素类型的指针。由于得到的不是数组类型，不能对动态数组调用<code>begin</code>或<code>end</code>。</li><li><p>默认情况下，<code>new</code>分配的对象，不管是单个分配还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一队空括号。在新标准中，还可以提供一个元素初始化器的花括号列表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *pia = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// block of ten uninitialized ints</span><br><span class="hljs-keyword">int</span> *pia2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>](); <span class="hljs-comment">// block of ten ints value initialized to 0</span><br>string *psa = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>]; <span class="hljs-comment">// block of ten empty strings</span><br>string *psa2 = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>](); <span class="hljs-comment">// block of ten empty strings</span><br><br><span class="hljs-comment">// block of ten ints each initialized from the corresponding initializer</span><br><span class="hljs-keyword">int</span> *pia3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-comment">// block of ten strings; the first four are initialized from the given initializers</span><br><span class="hljs-comment">// remaining elements are value initialized</span><br>string *psa3 = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>]&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-built_in">string</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;x&#x27;</span>)&#125;;<br></code></pre></td></tr></table></figure></li><li><p>为了释放动态数组，必须使用一种特殊形式的<code>delete</code>，在指针前加上一个空方括号对：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// p must point to a dynamically allocated object or be null</span><br><span class="hljs-keyword">delete</span> [] pa; <span class="hljs-comment">// pa must point to a dynamically allocated array or be null</span><br></code></pre></td></tr></table></figure></li><li><p>数组中的元素按逆序销毁。</p></li><li><p>指向数组的<code>unique_ptr</code></p><div align=center> <img src="/2019/09/16/DynamicMemory/12-6.png" class=""> </div></li><li><p>与<code>unique_ptr</code>不同，<code>shared_ptr</code>不支持直接管理动态数组，如果希望使用<code>shared_ptr</code>管理一个动态数组，必须提供自己定义的删除器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// to use a shared_ptr we must supply a deleter</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">sp</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>], [](<span class="hljs-keyword">int</span> *p) &#123; <span class="hljs-keyword">delete</span>[] p; &#125;)</span></span>;<br>sp.<span class="hljs-built_in">reset</span>(); <span class="hljs-comment">// uses the lambda we supplied that uses delete[] to free the array</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a><code>allocator</code>类</h3><ul><li>不能分配元素类型为“没有默认构造函数的类类型”的动态数组。</li><li><p>标准库<code>allocator</code>类及其算法</p><div align=center> <img src="/2019/09/16/DynamicMemory/12-7.png" class=""> </div></li><li><p><code>allocator</code>算法</p><div align=center> <img src="/2019/09/16/DynamicMemory/12-8.png" class=""> </div></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Associative Containers</title>
    <link href="/2019/09/10/AssociativeContainers/"/>
    <url>/2019/09/10/AssociativeContainers/</url>
    
    <content type="html"><![CDATA[<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><ul><li>关联容器类型<div align=center> <img src="/2019/09/10/AssociativeContainers/11-1.png" class=""> </div></li></ul><h1 id="使用关联容器"><a href="#使用关联容器" class="headerlink" title="使用关联容器"></a>使用关联容器</h1><ul><li><p>使用关联数组的一个典型例子是单词数统计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// count the number of times each word occurs in the input</span><br>map&lt;string, <span class="hljs-keyword">size_t</span>&gt; word_count; <span class="hljs-comment">// empty map from string to size_t</span><br>string word;<br><span class="hljs-keyword">while</span> (cin &gt;&gt; word)<br>        ++word_count[word];   <span class="hljs-comment">// fetch and increment the counter for word</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;w : word_count) <span class="hljs-comment">// for each element in the map</span><br>    <span class="hljs-comment">// print the results</span><br>    cout &lt;&lt;  w.first &lt;&lt; <span class="hljs-string">&quot; occurs &quot;</span> &lt;&lt; w.second<br>         &lt;&lt; ((w.second &gt; <span class="hljs-number">1</span>) ? <span class="hljs-string">&quot; times&quot;</span> : <span class="hljs-string">&quot; time&quot;</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p>若<code>word</code>不存在于<code>map</code>中，下标操作会创建一个键为<code>word</code>值为<code>0</code>的元素。</p></li><li><p>当我们从<code>map</code>中获取一个元素时，得到的元素类型为<code>pair</code>。</p></li></ul><h1 id="关联容器概述"><a href="#关联容器概述" class="headerlink" title="关联容器概述"></a>关联容器概述</h1><h2 id="定义关联容器"><a href="#定义关联容器" class="headerlink" title="定义关联容器"></a>定义关联容器</h2><ul><li>在<code>C++ 11</code>标准下，关联容器可以进行列表初始化：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">map&lt;string, <span class="hljs-keyword">size_t</span>&gt; word_count;  <span class="hljs-comment">// empty</span><br><span class="hljs-comment">// list initialization</span><br>set&lt;string&gt; exclude = &#123;<span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-string">&quot;but&quot;</span>, <span class="hljs-string">&quot;and&quot;</span>, <span class="hljs-string">&quot;or&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>,<br>                       <span class="hljs-string">&quot;The&quot;</span>, <span class="hljs-string">&quot;But&quot;</span>, <span class="hljs-string">&quot;And&quot;</span>, <span class="hljs-string">&quot;Or&quot;</span>, <span class="hljs-string">&quot;An&quot;</span>,<br><span class="hljs-string">&quot;A&quot;</span>&#125;;<br><span class="hljs-comment">// three elements; authors maps last name to first</span><br>map&lt;string, string&gt; authors = &#123; &#123;<span class="hljs-string">&quot;Joyce&quot;</span>, <span class="hljs-string">&quot;James&quot;</span>&#125;,<br>                                &#123;<span class="hljs-string">&quot;Austen&quot;</span>, <span class="hljs-string">&quot;Jane&quot;</span>&#125;,<br>                                &#123;<span class="hljs-string">&quot;Dickens&quot;</span>, <span class="hljs-string">&quot;Charles&quot;</span>&#125; &#125;;<br></code></pre></td></tr></table></figure><ul><li><code>map</code>或<code>set</code>中的键必须是唯一的，一个键只能对应容器中的一个元素；<code>multimap</code>和<code>multiset</code>没有这个限制，可以有多个元素具有相同的键。</li></ul><h2 id="键类型的要求"><a href="#键类型的要求" class="headerlink" title="键类型的要求"></a>键类型的要求</h2><ul><li><p>默认情况下，标准库使用键类型的<code>&lt;</code>运算符来比较两个键。</p></li><li><p>对于没有<code>&lt;</code>运算符的类型，可以在模板参数中提供比较操作类型（函数指针）：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compareIsbn</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Sales_data &amp;lhs, <span class="hljs-keyword">const</span> Sales_data &amp;rhs)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> lhs.<span class="hljs-built_in">isbn</span>() &lt; rhs.<span class="hljs-built_in">isbn</span>();<br>&#125;<br>multiset&lt;Sales_data, decltype(compareIsbn)*&gt; bookstore(compareIsbn);<br></code></pre></td></tr></table></figure></li><li><p>对函数名使用<code>decltype</code>时，必须添加<code>*</code>才能得到函数指针类型。</p></li></ul><h2 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a><code>pair</code>类型</h2><ul><li><code>pair</code>的默认构造函数对数据成员进行值初始化。</li><li><code>pair</code>上的操作<div align=center> <img src="/2019/09/10/AssociativeContainers/11-2.png" class=""> </div></li></ul><h1 id="关联容器操作"><a href="#关联容器操作" class="headerlink" title="关联容器操作"></a>关联容器操作</h1><ul><li>关联容器的额外类型别名<div align=center> <img src="/2019/09/10/AssociativeContainers/11-3.png" class=""> </div></li></ul><h2 id="关联容器迭代器"><a href="#关联容器迭代器" class="headerlink" title="关联容器迭代器"></a>关联容器迭代器</h2><ul><li><code>set</code>类型定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种迭代器对<code>set</code>的元素都只能进行只读访问。</li></ul><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><ul><li>关联容器<code>insert</code>操作<div align=center> <img src="/2019/09/10/AssociativeContainers/11-4.png" class=""> </div></li></ul><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><ul><li>从关联容器中删除元素<div align=center> <img src="/2019/09/10/AssociativeContainers/11-5.png" class=""> </div></li></ul><h2 id="map的下标操作"><a href="#map的下标操作" class="headerlink" title="map的下标操作"></a><code>map</code>的下标操作</h2><ul><li><code>map</code>和<code>unordered_map</code>的下标操作<div align=center> <img src="/2019/09/10/AssociativeContainers/11-6.png" class=""> </div></li></ul><h2 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h2><ul><li>在一个关联容器中查找元素的操作<div align=center> <img src="/2019/09/10/AssociativeContainers/11-7.png" class=""> </div></li></ul><h1 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h1><ul><li>无序容器管理操作<div align=center> <img src="/2019/09/10/AssociativeContainers/11-8.png" class=""> </div></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Generic Algorithm</title>
    <link href="/2019/09/06/GenericAlgorithm/"/>
    <url>/2019/09/06/GenericAlgorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><ul><li><p>对于一个对象或表达式，如果可以对其使用调用运算符，则称它为可调用的。</p></li><li><p>除函数与函数指针外，还有两种可调用对象：重载了函数调用运算符的类以及<strong>lambda表达式</strong>（lambda expression）。lambda表达式的基本形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture list] (parameter list) -&gt; <span class="hljs-keyword">return</span> type  &#123; function body &#125;<br></code></pre></td></tr></table></figure></li><li><p>与普通函数不同，lambda不能有默认参数。</p></li><li>如果lambda的函数体包含任何单一<code>return</code>语句之外的内容，且未指定返回类型，则返回<code>void</code>。</li><li>捕获列表只用于局部非<code>static</code>变量，lambda可以直接使用局部<code>static</code>变量和它所在函数之外声明的名字。</li><li>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。</li><li>lambda捕获列表</li></ul><div align=center> <img src="/2019/09/06/GenericAlgorithm/10-1.png" class=""> </div>- 如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。# 参数绑定- `functional`头文件中的`bind`函数可以接受一个可调用对象，生成一个新的可调用对象。调用`bind`的一般形式为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> newCallable = <span class="hljs-built_in">bind</span>(callable, arg_list);<br></code></pre></td></tr></table></figure>- `std::placeholder`命名空间中的`_n`是`bind`参数的占位符。对于`auto g = bind(f, a, b, _2, c, _1)`，调用`g(X, Y)`相当于调用`f(a, b, Y, c, X)`。- 默认情况下，`bind`中的非占位符参数被拷贝到`bind`返回的可调用对象中。如果希望传递给`bind`一个对象而又不拷贝它，就必须使用标准库`ref`函数：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">bind</span>(print, <span class="hljs-built_in">ref</span>(os), _1, <span class="hljs-string">&#x27; &#x27;</span>));<br></code></pre></td></tr></table></figure># 再探迭代器- 插入迭代器操作<div align=center> <img src="/2019/09/06/GenericAlgorithm/10-2.png" class=""> </div><ul><li><p><code>istream_iterator</code>操作</p><div align=center> <img src="/2019/09/06/GenericAlgorithm/10-3.png" class=""> </div></li><li><p><code>ostream_iterator</code>操作</p><div align=center> <img src="/2019/09/06/GenericAlgorithm/10-4.png" class=""> </div></li><li><p>对于绑定到流的迭代器，一旦其关联的流遇到文件结束或IO错误，迭代器的值就与尾迭代器相等。</p></li><li><p>对于反向迭代器，可以使用<code>base()</code>成员函数返回其对应的普通迭代器，下图显示了普通迭代器与反向迭代器之间的关系。</p><div align=center> <img src="/2019/09/06/GenericAlgorithm/10-6.png" class=""> </div></li><li><p>当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sequential Container</title>
    <link href="/2019/09/01/SequentialContainer/"/>
    <url>/2019/09/01/SequentialContainer/</url>
    
    <content type="html"><![CDATA[<h1 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h1><ul><li>顺序容器类型</li></ul><div align=center> <img src="/2019/09/01/SequentialContainer/9-1.png" class=""> </div>- 与`vector`、`deque`和`array`相比，`list`和`forward_list`的内存开销更大。# 容器库概览- 容器操作<div align=center> <img src="/2019/09/01/SequentialContainer/9-2-1.png" class=""> </div><div align=center> <img src="/2019/09/01/SequentialContainer/9-2-2.png" class=""> </div><ul><li><p>容器定义和初始化</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-3.png" class=""> </div></li><li><p>为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，不要求容器类型是相同的。而且，新容器和原容器中的元素类型也可以不同，只要能将拷贝的元素转换为要初始化的元素类型即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// each container has three elements, initialized from the given initializers</span><br>list&lt;string&gt; authors = &#123;<span class="hljs-string">&quot;Milton&quot;</span>, <span class="hljs-string">&quot;Shakespeare&quot;</span>, <span class="hljs-string">&quot;Austen&quot;</span>&#125;;<br>vector&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*&gt; articles = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;an&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>&#125;;<br><span class="hljs-function">list&lt;string&gt; <span class="hljs-title">list2</span><span class="hljs-params">(authors)</span></span>;     <span class="hljs-comment">// ok: types match</span><br><span class="hljs-function">deque&lt;string&gt; <span class="hljs-title">authList</span><span class="hljs-params">(authors)</span></span>; <span class="hljs-comment">// error: container types don&#x27;t match</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">words</span><span class="hljs-params">(articles)</span></span>;  <span class="hljs-comment">// error: element types must match</span><br><span class="hljs-comment">// ok: converts const char* elements to string</span><br><span class="hljs-function">forward_list&lt;string&gt; <span class="hljs-title">words</span><span class="hljs-params">(articles.begin(), articles.end())</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>如果元素是内置类型或具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。如果元素类型没有默认构造函数，则除了大小参数外，还必须指定一个显式的元素初始值。</p></li><li><p>与内置数组一样，标准库<code>array</code>的大小也是类型的一部分。</p></li><li><p>容器赋值运算</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-4.png" class=""> </div></li><li><p>对于<code>array</code>，<code>swap</code>会真正的交换它们的元素，在<code>swap</code>操作后，指针、引用和迭代器所绑定的元素不变，但元素值已经与另一个array中对应元素的值进行了交换。</p></li></ul><h1 id="顺序容器操作"><a href="#顺序容器操作" class="headerlink" title="顺序容器操作"></a>顺序容器操作</h1><ul><li>想顺序容器添加元素的操作<div align=center> <img src="/2019/09/01/SequentialContainer/9-5.png" class=""> </div></li><li>如果传递给<code>insert</code>一对迭代器，它们不能指向添加元素的目标容器。</li><li><code>emplace</code>函数在容器中直接构造元素。</li><li>在顺序容器中访问元素的操作<div align=center> <img src="/2019/09/01/SequentialContainer/9-6.png" class=""> </div></li><li><p>顺序表容器的删除操作</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-7.png" class=""> </div></li><li><p>在<code>forward_list</code>中插入或删除元素的操作</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-8.png" class=""> </div></li><li>顺序容器大小操作<div align=center> <img src="/2019/09/01/SequentialContainer/9-9.png" class=""> </div></li></ul><h1 id="vector对象是如何增长的"><a href="#vector对象是如何增长的" class="headerlink" title="vector对象是如何增长的"></a><code>vector</code>对象是如何增长的</h1><ul><li><p>容器大小管理操作</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-10.png" class=""> </div></li><li><p>若请求的容器大小小于或等于已有的容量，<code>reserve</code>不会进行任何操作。</p></li><li>调用<code>shrink_to_fit</code>并不保证一定退回内存空间。</li></ul><h1 id="string的额外操作"><a href="#string的额外操作" class="headerlink" title="string的额外操作"></a>string的额外操作</h1><ul><li><p>构造<code>string</code>的其他方法</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-11.png" class=""> </div></li><li><p><code>substr</code>操作</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-12.png" class=""> </div></li></ul><p>如果<code>pos + n</code>大于<code>string</code>的大小，则<code>substr</code>只拷贝到<code>string</code>的末尾。</p><ul><li><p>修改<code>string</code>的操作</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-13.png" class=""> </div></li><li><p><code>string</code>搜索操作</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-14.png" class=""> </div></li><li><p><code>s.compare</code>的几种参数形式</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-15.png" class=""> </div></li><li><p><code>string</code>与数值之间的转换</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-16.png" class=""> </div></li></ul><h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><ul><li><p>所有容器适配器都支持的操作和类型</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-17.png" class=""> </div></li><li><p>默认情况下，<code>stack</code>和<code>queue</code>基于<code>deque</code>实现，<code>priority_queue</code>基于<code>vector</code>实现。可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，重载默认容器类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// empty stack implemented on top of vector</span><br>stack&lt;string, vector&lt;string&gt;&gt; str_stk;<br><span class="hljs-comment">// str_stk2 is implemented on top of vector and initially holds a copy of svec</span><br>stack&lt;string, vector&lt;string&gt;&gt; <span class="hljs-built_in">str_stk2</span>(svec);<br></code></pre></td></tr></table></figure></li><li><p><code>stack</code>的特有操作</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-18.png" class=""> </div></li><li><p><code>queue</code>和<code>priority_queue</code>的特有操作</p><div align=center> <img src="/2019/09/01/SequentialContainer/9-19.png" class=""> </div></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The IO Library</title>
    <link href="/2019/08/29/190829IO-Library/"/>
    <url>/2019/08/29/190829IO-Library/</url>
    
    <content type="html"><![CDATA[<h1 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h1><ul><li>IO库类型和头文件<div align=center> <img src="/2019/08/29/190829IO-Library/8-1.png" class=""> </div></li></ul><h2 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h2><ul><li>由于不能拷贝IO对象，我们不能将函数的形参或返回类型设为流类型。</li></ul><h2 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h2><ul><li>IO库条件状态<div align=center> <img src="/2019/08/29/190829IO-Library/8-2.png" class=""> </div></li></ul><h2 id="管理输出缓冲"><a href="#管理输出缓冲" class="headerlink" title="管理输出缓冲"></a>管理输出缓冲</h2><ul><li>导致缓冲刷新的条件有以下几种：<ul><li>程序正常结束</li><li>缓冲区满</li><li>使用<code>endl</code>, <code>flush</code>等操纵符显式刷新缓冲</li><li>使用<code>unitbuf</code>操纵符设置流的内部状态，使流在每次输出操作后自动刷新缓冲</li><li>一个输出流A可以关联到另一个流B，此时读写B时，A的缓冲区会被刷新</li></ul></li><li>有两个与<code>endl</code>类似的操纵符：<code>flush</code>和<code>ends</code>。<code>flush</code>刷新缓冲区但不向输出添加任何字符；<code>ends</code>在缓冲区末尾插入一个空字符，然后刷新缓冲区。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">cout &lt;&lt; <span class="hljs-string">&quot;hi!&quot;</span> &lt;&lt; endl;   <span class="hljs-comment">// writes hi and a newline, then flushes the buffer</span><br>cout &lt;&lt; <span class="hljs-string">&quot;hi!&quot;</span> &lt;&lt; flush;  <span class="hljs-comment">// writes hi, then flushes the buffer; adds no data</span><br>cout &lt;&lt; <span class="hljs-string">&quot;hi!&quot;</span> &lt;&lt; ends;   <span class="hljs-comment">// writes hi and a null, then flushes the buffer</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h1><ul><li><code>fstream</code>特有操作<div align=center> <img src="/2019/08/29/190829IO-Library/8-3.png" class=""> </div></li></ul><h2 id="使用文件流对象"><a href="#使用文件流对象" class="headerlink" title="使用文件流对象"></a>使用文件流对象</h2><ul><li>当<code>fstream</code>对象被销毁时，会自动调用<code>close</code>。</li></ul><h2 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h2><ul><li><p>文件模式</p><div align=center> <img src="/2019/08/29/190829IO-Library/8-4.png" class=""> </div></li><li><p>默认情况下，当我们打开一个<code>ofstream</code>时，文件的内容会被丢弃。阻止一个<code>ofsteam</code>清空给定文件内容的方法是同时指定<code>app</code>模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// file1 is truncated in each of these cases</span><br><span class="hljs-function">ofstream <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>)</span></span>;   <span class="hljs-comment">// out and trunc are implicit</span><br><span class="hljs-function">ofstream <span class="hljs-title">out2</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::out)</span></span>;   <span class="hljs-comment">// trunc is implicit</span><br><span class="hljs-function">ofstream <span class="hljs-title">out3</span><span class="hljs-params">(<span class="hljs-string">&quot;file1&quot;</span>, ofstream::out | ofstream::trunc)</span></span>;<br><span class="hljs-comment">// to preserve the file&#x27;s contents, we must explicitly specify app mode</span><br><span class="hljs-function">ofstream <span class="hljs-title">app</span><span class="hljs-params">(<span class="hljs-string">&quot;file2&quot;</span>, ofstream::app)</span></span>;   <span class="hljs-comment">// out is implicit</span><br><span class="hljs-function">ofstream <span class="hljs-title">app2</span><span class="hljs-params">(<span class="hljs-string">&quot;file2&quot;</span>, ofstream::out | ofstream::app)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h1 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h1><ul><li>stringstream特有操作<div align=center> <img src="/2019/08/29/190829IO-Library/8-5.png" class=""> </div></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Classes</title>
    <link href="/2019/08/27/190827classes/"/>
    <url>/2019/08/27/190827classes/</url>
    
    <content type="html"><![CDATA[<h1 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h1><ul><li>成员函数必须在类的内部声明，可以在类的内部或外部定义。定义在类内部的函数是隐式的<code>inline</code>函数。</li><li><p>调用成员函数时，<code>this</code>被初始化为调用成员函数的对象的地址。普通成员函数的<code>this</code>为指向非<code>const</code>对象的<code>const</code>指针，<code>const</code>成员函数的<code>this</code>为指向<code>const</code>对象的<code>const</code>指针。</p></li><li><p><code>const</code>对象以及指向<code>const</code>对象的引用或指针只能调用对象的<code>const</code>成员函数。</p></li><li>构造函数在创建类类型的对象时执行。构造函数不能被声明为<code>const</code>。当我们在创建一个类的<code>const</code>对象时，构造函数可以向对象写入值。</li><li>若一个类定义了构造函数，该类就不会再有默认构造函数，除非我们自己定义默认构造函数。</li></ul><h1 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h1><ul><li><code>struct</code>关键字的默认访问权限为<code>public</code>，<code>class</code>关键字的默认访问权限为<code>private</code>。</li></ul><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><ul><li>如果类想把一个函数作为它的友元，只需要增加一条以<code>friend</code>关键字开始的函数声明语句即可。</li><li>友元声明只能出现在类定义的内部，但在类内出现的具体位置不限。友元不是类的成员，也不受访问控制的约束。</li><li>友元的声明仅仅指定了访问的权限，而非一个真正意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再对函数进行一次声明。</li></ul><h1 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h1><h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2><ul><li>由类定义的类型名与其他类成员一样存在访问权限控制，可以是<code>public</code>或<code>private</code>中的一种。</li><li>不同于普通成员，定义类型的成员必须先定义后使用。</li><li><code>mutable</code>数据成员永远不是<code>const</code>，即使它是<code>const</code>对象的成员。</li></ul><h2 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回<code>*this</code>的成员函数</h2><ul><li>一个<code>const</code>成员函数如果以引用的形式返回<code>*this</code>，那么它的返回类型是对<code>const</code>的引用。</li></ul><h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><ul><li>可以只声明但不定义一个类，这样的声明称为<strong>前向声明</strong>（forward declaration），声明的类在定义之前称为<strong>不完全类型</strong>（incomplete type）。</li><li>不完全类型只能用于以下情形：定义不完全类型的指针或引用；声明（而不是定义）函数时，使用不完全类型作为参数或返回类型。</li></ul><h1 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h1><h2 id="名字查找与类的作用域"><a href="#名字查找与类的作用域" class="headerlink" title="名字查找与类的作用域"></a>名字查找与类的作用域</h2><ul><li>编译器处理完类内所有声明之后再处理成员函数的定义。</li><li>由于成员函数的函数体在整个类可见之后才被处理，因此它能使用类中定义的任何名字。但在类中的声明使用的名字必须在使用前确保可见。</li><li>在类中，如果一个成员使用了在外层作用域中定义的类型名，则类之后将不能重新定义该名字。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> Money;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Money <span class="hljs-title">balance</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> bal; &#125;  <span class="hljs-comment">// uses Money from the outer scope</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> Money; <span class="hljs-comment">// error: cannot redefine Money</span><br>    Money bal;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h1 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h1><h2 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h2><ul><li>如果成员是<code>const</code>或引用的话，构造函数必须将其初始化。</li><li>类成员初始化的顺序由它们在类定义中出现的顺序决定，与构造函数初始化列表中的顺序无关。</li></ul><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><ul><li>委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sales_data</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// nondelegating constructor initializes members from corresponding arguments</span><br>    <span class="hljs-built_in">Sales_data</span>(std::string s, <span class="hljs-keyword">unsigned</span> cnt, <span class="hljs-keyword">double</span> price):<br>            <span class="hljs-built_in">bookNo</span>(s), <span class="hljs-built_in">units_sold</span>(cnt), <span class="hljs-built_in">revenue</span>(cnt*price) &#123;<br>&#125;<br>    <span class="hljs-comment">// remaining constructors all delegate to another constructor</span><br>    <span class="hljs-built_in">Sales_data</span>(): <span class="hljs-built_in">Sales_data</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">Sales_data</span>(std::string s): <span class="hljs-built_in">Sales_data</span>(s, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">Sales_data</span>(std::istream &amp;is): <span class="hljs-built_in">Sales_data</span>()<br>                                        &#123; <span class="hljs-built_in">read</span>(is, *<span class="hljs-keyword">this</span>); &#125;<br>    <span class="hljs-comment">// other members as before</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li>受委托的构造函数会先执行。</li></ul><h2 id="隐式类类型转换"><a href="#隐式类类型转换" class="headerlink" title="隐式类类型转换"></a>隐式类类型转换</h2><ul><li>可以将构造函数声明为<code>explicit</code>以避免隐式类型转换。</li></ul><h2 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h2><ul><li><strong>聚合类</strong>（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足以下条件时，我们说它是聚合的：<ul><li>所有数据成员都是<code>public</code>的。</li><li>没有定义任何构造函数。</li><li>没有类内初始值。</li><li>没有基类，也没有<code>virtual</code>函数。</li></ul></li><li>可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span> &#123;</span><br>    <span class="hljs-keyword">int</span> ival;<br>    string s;<br>&#125;;<br><span class="hljs-comment">// val1.ival = 0; val1.s = string(&quot;Anna&quot;)</span><br>Data val1 = &#123; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Anna&quot;</span> &#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h2><h1 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h1><ul><li>一般来说，不能在类的内部初始化静态成员，必须在类的外部定义和初始化每个静态成员。然而，我们可以为静态成员提供<code>const</code>整数类型的类内初始值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Functions</title>
    <link href="/2019/08/19/190819functions/"/>
    <url>/2019/08/19/190819functions/</url>
    
    <content type="html"><![CDATA[<h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><ul><li>实参（argument）是函数形参（parameter）的初始值。</li><li>虽然实参与形参存在对应关系，但C++对实参的求值顺序没有保证。</li><li>形参名是可选的，某些情况下函数的某些形参是未被用到的，此类形参通常不命名以表示在函数体内不会使用它。函数调用必须为每个形参提供实参，即使这个形参不会被用到。</li><li>函数的返回值不能为数组或函数类型，但可以是指向数组或函数的指针。</li></ul><h2 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h2><ul><li>只存在于块执行期间的对象为<strong>自动对象</strong>（automatic object）。</li><li>对于局部变量对应的自动对象，有两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化；否则执行默认初始化。</li><li><strong>局部静态对象</strong>（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并在程序结束时被销毁，在此期间对象所在函数执行结束不会对它造成影响。</li><li>如果局部静态对象没有显式的初始值，他将执行值初始化，这意味着内置类型的局部静态对象被初始化为0。</li></ul><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><ul><li>由于函数声明没有函数体，可以在声明中省去形参名。</li><li>返回值类型、函数名和形参类型描述了函数的接口，并说明了调用函数需要的信息。函数声明也被称为<strong>函数原型</strong>（function prototype）。</li></ul><h2 id="分离式编译"><a href="#分离式编译" class="headerlink" title="分离式编译"></a>分离式编译</h2><ul><li><p>为了允许编写程序时按照逻辑关系将其划分开，C++支持<em>分离式编译</em>。分类式编译允许我们将程序划分到几个文件中，每个文件可以独立编译。</p></li><li><p>为了生成可执行文件，必须告诉编译器如何找到所有的代码。假设<code>fact</code>函数的定义位于<code>fact.c</code>文件中，它的声明位于<code>Chapter6.h</code>头文件中。另外在<code>factMain.cc</code>文件中创建<code>main</code>函数，<code>main</code>函数将调用<code>fact</code>函数。对于上述几个文件，编译过程如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> g++ factMain.cc fact.cc -o main</span><br></code></pre></td></tr></table></figure></li><li><p>如果只修改了其中一个源文件，可以只重新编译修改的文件。大多数编译器都提供了分离式编译单个文件的机制，这个过程会产生<code>.obj</code>（Windows）或<code>.o</code>（Unix）文件，后缀名的含义是该文件包含<em>对象代码</em>（object code）。接下来编译器将对象文件<em>链接</em>在一起形成可执行文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> g++ -c factMain.cc                <span class="hljs-comment"># generates factMain.o</span></span><br><span class="hljs-meta">$</span><span class="bash"> g++ -c fact.cc                    <span class="hljs-comment"># generates fact.o</span></span><br><span class="hljs-meta">$</span><span class="bash"> g++ factMain.o fact.o -o main     <span class="hljs-comment"># generates main</span></span><br></code></pre></td></tr></table></figure></li></ul><h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><ul><li>如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。</li></ul><h2 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h2><h2 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h2><ul><li>如果无需改变引用形参的值，最好将其声明为常量引用。</li></ul><h2 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a><code>const</code>形参和实参</h2><ul><li><p>在C++中，我们可以定义名字相同的函数，但这些函数的形参列表必须有足够的区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> i)</span> </span>&#123; <span class="hljs-comment">/* fcn can read but not write to i */</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fcn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">//error: redefines fcn(int)</span><br></code></pre></td></tr></table></figure></li><li><p>可用非<code>const</code>对象来初始化底层<code>const</code>对象，但反过来不行。一个普通的引用必须用相同类型的对象初始化。</p></li></ul><h2 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h2><ul><li>因为数组不能被拷贝，所以我们无法以值传递的方式使用数组参数。因为数组会被转换为指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</li><li><p>以下声明是等价的：都声明了具有一个<code>const int*</code>类型形参的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// despite apperances, these three declaration of print are equivalent</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>*)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>[])</span></span>;    <span class="hljs-comment">// shows the intent that the function takes an array</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>])</span></span>;  <span class="hljs-comment">// dimension for decumentation purposes (at best)</span><br></code></pre></td></tr></table></figure></li><li><p>使用标记指定数组长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *cp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (cp)                <span class="hljs-comment">// if cp is not a null pointer</span><br>        <span class="hljs-keyword">while</span> (*cp)        <span class="hljs-comment">// so long as the character it points to is not a null character</span><br>            cout &lt;&lt; *cp++; <span class="hljs-comment">// print the character and advance the pointer</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用标准库规范</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *beg, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// print every element starting at beg up to but not including end</span><br>    <span class="hljs-keyword">while</span> (beg != end)<br>        cout &lt;&lt; *beg++ &lt;&lt; endl; <span class="hljs-comment">// print the current element</span><br>                                <span class="hljs-comment">// and advance the pointer</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>显式传递一个表示数组大小的形参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// const int ia[] is equivalent to const int* ia</span><br><span class="hljs-comment">// size is passed explicitly and used to control access to elements of ia</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ia[], <span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i != size; ++i) &#123;<br>        cout &lt;&lt; ia[i] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>传递多维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// matrix points to the first element in an array whose elements are arrays of ten ints</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*matrix)[<span class="hljs-number">10</span>], <span class="hljs-keyword">int</span> rowSize)</span> </span>&#123; <span class="hljs-comment">/* . . . */</span> &#125;<br></code></pre></td></tr></table></figure></li><li>也可以使用数组的语法，此时编译器会忽略第一个维度：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// equivalent definition</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> matrix[][<span class="hljs-number">10</span>], <span class="hljs-keyword">int</span> rowSize)</span> </span>&#123; <span class="hljs-comment">/* . . . */</span> &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="main-处理命令行选项"><a href="#main-处理命令行选项" class="headerlink" title="main:处理命令行选项"></a><code>main</code>:处理命令行选项</h2><h2 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h2><ul><li>如果函数形参的数量未知但它们的类型相同，可以使用<code>initializer_list</code>类型的形参。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">error_msg</span><span class="hljs-params">(initializer_list&lt;string&gt; il)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> beg = il.<span class="hljs-built_in">begin</span>(); beg != il.<span class="hljs-built_in">end</span>(); ++beg)<br>        cout &lt;&lt; *beg &lt;&lt; <span class="hljs-string">&quot; &quot;</span> ;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和<code>return</code>语句</h1><h2 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h2><ul><li>返回值类型为<code>void</code>的函数可以返回另一个返回值为<code>void</code>的函数。</li></ul><h2 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h2><ul><li>函数调用是否为左值取决于函数的返回类型：调用一个返回引用的函数得到左值，其他返回类型得到右值。</li><li>列表初始化返回值：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">process</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// . . .</span><br>    <span class="hljs-comment">// expected and actual are strings</span><br>    <span class="hljs-keyword">if</span> (expected.<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> &#123;&#125;;  <span class="hljs-comment">// return an empty vector</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (expected == actual)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;functionX&quot;</span>, <span class="hljs-string">&quot;okay&quot;</span>&#125;; <span class="hljs-comment">// return list-initialized vector</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;functionX&quot;</span>, expected, actual&#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占的空间不能大于目标类型的空间。</p></li><li><p>如果<code>main</code>函数的结尾没有<code>return</code>语句，编译器将隐式的插入一条返回<code>0</code>的<code>return</code>语句。</p></li></ul><h2 id="返回指向数组的指针"><a href="#返回指向数组的指针" class="headerlink" title="返回指向数组的指针"></a>返回指向数组的指针</h2><ul><li>定义一个返回数组的指针最直接的方法是使用类型别名：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> arrT[<span class="hljs-number">10</span>];  <span class="hljs-comment">// arrT is a synonym for the type array of ten ints</span><br><span class="hljs-keyword">using</span> arrtT = <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// equivalent declaration of arrT</span><br><span class="hljs-function">arrT* <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;     <span class="hljs-comment">// func returns a pointer to an array of five ints</span><br></code></pre></td></tr></table></figure></li><li>与以下声明相同，如果要定义一个返回数组指针的函数，则数组的维度必须跟在函数名之后。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>];          <span class="hljs-comment">// arr is an array of ten ints</span><br><span class="hljs-keyword">int</span> *p1[<span class="hljs-number">10</span>];          <span class="hljs-comment">// p1 is an array of ten pointers</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*p2)[<span class="hljs-number">10</span>] = &amp;arr; <span class="hljs-comment">// p2 points to an array of ten ints</span><br></code></pre></td></tr></table></figure></li><li><p>因此，返回数组指针的函数形式如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Type</span> (*<span class="hljs-built_in">function</span>(parameter_list))[dimension]<br></code></pre></td></tr></table></figure></li><li><p>在C++11新标准中，可以使用<strong>尾置返回类型</strong>（trailing return type）简化函数声明。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// fcn takes an int argument and returns a pointer to an array of ten ints</span><br>auto func(int i) -&gt; int(*)[10];<br></code></pre></td></tr></table></figure></li><li><p><code>decltype</code>不会自动将数组转换为对应的指针类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> odd[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">int</span> even[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;<br><span class="hljs-comment">// returns a pointer to an array of five int elements</span><br><span class="hljs-keyword">decltype</span>(odd) *<span class="hljs-built_in">arrPtr</span>(<span class="hljs-keyword">int</span> i)<br>&#123;<br>    <span class="hljs-keyword">return</span> (i % <span class="hljs-number">2</span>) ? &amp;odd : &amp;even; <span class="hljs-comment">// returns a pointer to the array</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h1 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h1><ul><li>对于重载函数来说，它们必须在形参数量或形参类型上有所不同。</li><li><p>一个拥有顶层<code>const</code>的形参无法和另一个没有顶层<code>const</code>的形参区分开。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Phone)</span></span>;   <span class="hljs-comment">// redeclares Record lookup(Phone)</span><br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone*)</span></span>;<br><span class="hljs-function">Record <span class="hljs-title">lookup</span><span class="hljs-params">(Phone* <span class="hljs-keyword">const</span>)</span></span>;  <span class="hljs-comment">// redeclares Record lookup(Phone*)</span><br></code></pre></td></tr></table></figure></li><li><p>如果形参是某种类型的指针或引用，则通过区分其指向的是<code>const</code>对象还是非<code>const</code>对象可以实现函数重载，此时的<code>const</code>是底层的。</p></li></ul><h1 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h1><h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><ul><li>默认实参用于函数调用中最右端的实参。</li><li><p>通常一个函数只在头文件中声明一次，但多次声明一个函数也是合法的。但一个形参在给定作用域内只能赋予一次默认实参，随后的函数声明只能为之前未设置默认值的形参添加一个默认实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">screen</span><span class="hljs-params">(sz, sz, <span class="hljs-keyword">char</span> = <span class="hljs-string">&#x27; &#x27;</span>)</span></span>;        <span class="hljs-comment">// no default for the height or width parameters</span><br><span class="hljs-function">string <span class="hljs-title">screen</span><span class="hljs-params">(sz, sz, <span class="hljs-keyword">char</span> = <span class="hljs-string">&#x27;*&#x27;</span>)</span></span>;        <span class="hljs-comment">// error: redeclaration</span><br><span class="hljs-function">string <span class="hljs-title">screen</span><span class="hljs-params">(sz = <span class="hljs-number">24</span>, sz = <span class="hljs-number">80</span>, <span class="hljs-keyword">char</span>)</span></span>;    <span class="hljs-comment">// ok: add default arguements</span><br></code></pre></td></tr></table></figure></li><li><p>局部变量不能用作默认参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// the declarations of wd, def, and ht must appear outside a function</span><br>sz wd = <span class="hljs-number">80</span>;<br><span class="hljs-keyword">char</span> def = <span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-function">sz <span class="hljs-title">ht</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">string <span class="hljs-title">screen</span><span class="hljs-params">(sz = ht(), sz = wd, <span class="hljs-keyword">char</span> = def)</span></span>;<br>string window = <span class="hljs-built_in">screen</span>();    <span class="hljs-comment">// calls screen(ht(), 80, &#x27; &#x27;)</span><br></code></pre></td></tr></table></figure></li><li><p>用作默认参数的名字在函数声明所在的作用域内解析，这些名字在函数调用时求值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    def = <span class="hljs-string">&#x27;*&#x27;</span>;         <span class="hljs-comment">// changes the value of a default argument</span><br>    sz wd = <span class="hljs-number">100</span>;       <span class="hljs-comment">// hides the outer definition of wd but does not change the default</span><br>    window = <span class="hljs-built_in">screen</span>(); <span class="hljs-comment">// calls screen(ht(), 80. &#x27;*&#x27;)</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和<code>constexpr</code>函数</h2><ul><li><p>定义<code>constexpr</code>函数的方法与其他函数类似，但要遵循几项约定：函数的返回类型以及所有形参类型都必须是字面类型，而且函数体中必须有且只有一条<code>return</code>语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> <span class="hljs-title">new_sz</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> foo = <span class="hljs-built_in">new_sz</span>();  <span class="hljs-comment">// ok: foo is a constant expression</span><br></code></pre></td></tr></table></figure></li><li><p><code>constexpr</code>函数被隐式地指定为内联函数。</p></li><li><p>我们允许<code>constexpr</code>函数返回一个非常量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// scale(arg) is a constant expression if arg is a constant expression</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> cnt)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">new_sz</span>() * cnt; &#125;<br></code></pre></td></tr></table></figure></li><li><p>内联函数和<code>constexpr</code>函数可以在程序中多次定义，编译器需要函数定义而非函数声明来展开函数。不过，对于某个给定的内联函数或<code>constexpr</code>函数，它的多个定义必须完全一致。基于这个原因，内联函数和<code>constexpr</code>函数通常定义在头文件中。</p></li></ul><h2 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h2><ul><li><code>assert</code>预处理宏</li><li><code>NDEBUG</code>预处理变量</li></ul><h1 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h1><ul><li><strong>候选函数</strong>（candidate function）具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。</li><li><strong>可行函数</strong>（viable function）也具备两个特征：一是其形参数量与函数调用提供的实参数量相等，二是每个实参的类型与形参的类型相同，或者能转换成形参的类型。</li><li>若有多个可行函数都在某一个实参上实现了更好的匹配，该函数调用会因具有二义性被拒绝。</li></ul><h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><ul><li><p>函数的类型取决于它的返回类型以及形参的类型，与函数名无关。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// compares lengths of two strings</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">lengthCompare</span><span class="hljs-params">(<span class="hljs-keyword">const</span> string &amp;, <span class="hljs-keyword">const</span> string &amp;)</span></span>;<br><br><span class="hljs-comment">// pf points to a function returning bool that takes two const string references</span><br><span class="hljs-built_in"><span class="hljs-keyword">bool</span></span> (*pf)(<span class="hljs-keyword">const</span> string &amp;, <span class="hljs-keyword">const</span> string &amp;);  <span class="hljs-comment">// uninitialized</span><br></code></pre></td></tr></table></figure></li><li><p>当函数名被作为一个值使用时，该函数自动地转换成指针。</p></li><li><p>不同于将函数类型传递给形参的情况，返回类型不会自动转换为指针，必须显式地将返回类型指定为指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> F = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>);     <span class="hljs-comment">// F is a function type, not a pointer</span><br><span class="hljs-keyword">using</span> PF = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(*)(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>); <span class="hljs-comment">// PF is a pointer type</span><br><br><span class="hljs-function">PF <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">// ok: PF is a pointer to function; f1 returns a pointer to function</span><br><span class="hljs-function">F <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;  <span class="hljs-comment">// error: F is a function type; f1 can&#x27;t return a function</span><br><span class="hljs-function">F *<span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>; <span class="hljs-comment">// ok: explicitly specify that the return type is a pointer to function</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*<span class="hljs-built_in">f1</span>(<span class="hljs-keyword">int</span>))(<span class="hljs-keyword">int</span>*, <span class="hljs-keyword">int</span>); <span class="hljs-comment">// declare f1 directly</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Statements</title>
    <link href="/2019/08/09/190809statements/"/>
    <url>/2019/08/09/190809statements/</url>
    
    <content type="html"><![CDATA[<h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><code>switch</code>语句</h1><ul><li>c++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">case</span> <span class="hljs-literal">true</span>: <span class="hljs-comment">// this switch statement is illegal because these initializations might be bypassed</span><br>    string file_name; <span class="hljs-comment">// error: control bypasses an implicitly initialized variable</span><br>    <span class="hljs-keyword">int</span> ival = <span class="hljs-number">0</span>;     <span class="hljs-comment">// error: control bypasses an explicitly initialized variable</span><br>    <span class="hljs-keyword">int</span> jval;         <span class="hljs-comment">// ok: because jval is not initialized</span><br>    <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">false</span>:<br>    <span class="hljs-comment">// ok: jval is in scope but is uninitialized</span><br>    jval = <span class="hljs-built_in">next_num</span>(); <span class="hljs-comment">// ok: assign a value to jval</span><br>    <span class="hljs-keyword">if</span> (file_name.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">// file_name is in scope but wasn&#x27;t initialized</span><br>        <span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h1><ul><li>标签标识符独立于变量名和其他标识符。</li><li>与<code>switch</code>语句相同，<code>goto</code>无法跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。</li><li>跳转到一个变量创建前的位置会销毁该变量并重新创建。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Expressions</title>
    <link href="/2019/08/07/190807cpp/"/>
    <url>/2019/08/07/190807cpp/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>当我们使用重载运算符时，操作数的类型以及运算的结果都取决于运算的定义；然而，操作数的个数以及运算符的优先级和结合性都是无法改变的。</li><li>C++中所有的表达式都是<strong>右值</strong>（rvalue）或是<strong>左值</strong>（lvalue），这两个概念继承自C语言，原本是为了帮助记忆：左值可以放在赋值语句左侧，而右值不能（在C++中有所区别）。</li><li>通常，我们使用一个右值时，使用的是对象的值（内容）；我们使用一个左值时，使用的是对象的身份（在内存中的位置）。</li><li>一个重要的原则是（在13.6节中有一个例外），当需要使用右值时可以使用左值代替，但不能把右值当成左值使用。</li><li>内置类型以及迭代器的递增递减运算作用于左值运算对象，其前置版本返回结果也是左值。</li><li>将<code>decltype</code>应用于表达式（而非变量）时，若表达式产生左值，结果将是引用类型。</li></ul><h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><ul><li><p>对于不指定求值顺序的运算符，在一个表达式中引用并改变相同的对象是错误的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ++i &lt;&lt; endl; <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure></li><li><p>有4个运算符保证了运算对象的求值顺序：逻辑与运算符（&amp;&amp;），逻辑或运算符（||），条件运算符（?:）和逗号运算符（,）。</p></li></ul><h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><ul><li><p>以下代码中，对<code>short_value</code>的赋值是未定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">short</span> short_value = <span class="hljs-number">32767</span>;    <span class="hljs-comment">// max value of shorts are 16 bits</span><br>short_value += <span class="hljs-number">1</span>;             <span class="hljs-comment">// this calculation overflows</span><br>cout &lt;&lt; <span class="hljs-string">&quot;short_value: &quot;</span> &lt;&lt; short_value &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p><code>(-m) / n</code>和<code>m / (-n)</code>的值与<code>-(m / n)</code>相等，<code>m % (-n)</code>与<code>m % n</code>相等，<code>(-m) % n</code>和<code>-(m % n)</code>相等。</p></li></ul><h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><ul><li>如果左侧运算对象是内置类型，那么初始化列表中只能包含一个值，并且在强制转化中不能丢失信息。</li><li>无论左侧运算对象的类型是什么，初始化列表都可以为空；此时编译器会创建一个值初始化的临时量并将其赋给左侧运算对象。</li><li>使用复合赋值运算符对左侧运算对象只求值一次，普通赋值运算符则求值两次。</li></ul><h1 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h1><ul><li>递增和递减运算符作用于左值运算对象，前置版本将对象本身作为左值返回，后置版本将对象初始值的副本作为右值返回。</li><li>以下代码是未定义行为：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (beg != s.<span class="hljs-built_in">end</span>() &amp;&amp; !<span class="hljs-built_in">isspace</span>(*beg))<br>    *beg = <span class="hljs-built_in">toupper</span>(*beg++); <span class="hljs-comment">// error: this assignment is undefined</span><br></code></pre></td></tr></table></figure></li></ul><p>问题在于：<code>=</code>的两侧都使用了<code>beg</code>并且右侧运算对象改变了<code>beg</code>。</p><h1 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h1><ul><li>解引用运算符的优先级低于点运算符。</li></ul><h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h1><ul><li>若条件运算符的两个表达式都是左值或者都能转换成同一种左值类型时，运算的结果是左值，否则结果为右值。</li><li>条件运算符是右结合的：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">finalgrade = (grade &gt; <span class="hljs-number">90</span>) ? <span class="hljs-string">&quot;high pass&quot;</span> <br>                          : (grade &lt; <span class="hljs-number">60</span>) ? <span class="hljs-string">&quot;fail&quot;</span> : <span class="hljs-string">&quot;pass&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><ul><li>通常，如果运算对象是一个“小整型”，则它的值首先会自动转换为较大的整数类型。</li><li>左移运算符（<code>&lt;&lt;</code>）在右侧插入<code>0</code>二进制位。右移运算符（<code>&gt;&gt;</code>）的行为取决于左侧运算对象的类型：若该运算对象为<code>unsigned</code>类型，则在左侧插入<code>0</code>二进制位；若该运算对象为<code>signed</code>类型，则在左侧插入符号位的拷贝或者<code>0</code>，取决于具体实现。</li><li>位移运算符具有中等的优先级：低于算术运算符，但高于关系、赋值和条件运算符。</li></ul><h1 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a><code>sizeof</code>运算符</h1><ul><li><code>sizeof</code>返回的结果为常量表达式，其类型为<code>size_t</code>。</li><li><code>sizeof</code>不对其运算对象进行求值。</li></ul><h1 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h1><ul><li>与逻辑与、逻辑或和条件运算符相同，逗号运算符保证了运算对象求值的顺序。</li><li>逗号运算符左侧的表达式在求值后被舍弃。逗号运算符的结果是右侧表达式的值，若右侧运算对象为左值，那么最终结果也是左值。</li></ul><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><ul><li>如果两种类型可以<strong>相互转换</strong>（conversion），那么它们就是相关联的。</li><li>大多数情况下，如果表达式中既有整数类型运算对象也有浮点数类型的运算对象，整型会被转换为浮点型。</li><li>在以下情况下，编译器会自动转换运算对象的类型：<ul><li>在大多数表达式中，比<code>int</code>类型小的整型值首先提升为较大的整数类型。</li><li>在条件中，非布尔值转换为布尔值。</li><li>初始化过程中，初始值转化为变量的类型；在赋值语句中，右侧运算对象转换为左侧运算对象的类型。</li><li>若果算术运算或关系运算的运算对象有多种类型，需要转换为同一种类型。</li><li>函数调用时也会发生类型转换。</li></ul></li></ul><h2 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h2><ul><li>算术转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。</li></ul><h2 id="其他隐式类型转换"><a href="#其他隐式类型转换" class="headerlink" title="其他隐式类型转换"></a>其他隐式类型转换</h2><ul><li><p><strong>数组转化为指针</strong>：在大多数用到数组的表达式中，数组自动转换为指向数组首元素的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ia[<span class="hljs-number">10</span>];    <span class="hljs-comment">// array of ten ints</span><br><span class="hljs-keyword">int</span>* ip = ia;  <span class="hljs-comment">// convert ia to a pointer to the first element</span><br></code></pre></td></tr></table></figure><p>当数组被用作<code>decltype</code>关键字的参数，或者作为取地址符（<code>&amp;</code>）、<code>sizeof</code>或<code>typeid</code>运算符的运算对象时，上述转换不会发生。</p></li><li><p><strong>指针转换</strong>：常量整数值<code>0</code>及字面值<code>nullptr</code>能转换为任意指针类型；指向任意非常量的指针能转换成<code>void*</code>；指向任意对象的指针可转换为<code>const void*</code>。</p></li></ul><h2 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h2><ul><li><p>命名的强制类型转换形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cast-name&lt;type&gt; (expression);<br></code></pre></td></tr></table></figure><p>若<code>type</code>是引用类型，则结果是左值。</p></li><li><p>任何具有明确意义的类型转换，只要不包含底层<code>const</code>，都可以使用<code>static_cast</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> slope = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">double</span>&gt;(j) / i;<br></code></pre></td></tr></table></figure></li><li><p><code>const_cast</code>只能改变运算对象的底层<code>const</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pc;<br><span class="hljs-keyword">char</span> *p = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">char</span>*&gt;(pc); <span class="hljs-comment">// ok: but writing through p is undefined</span><br></code></pre></td></tr></table></figure></li></ul><p>只有<code>const_cast</code>能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译时错误。同样的，不能使用<code>const_cast</code>改变表达式的类型。<code>const_cast</code>常用于有函数重载的上下文中。</p><ul><li><code>reinterpret_cast</code>通常为运算对象的位模式提供较低层次上的重新解释。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strings, Vectors, and Arrays</title>
    <link href="/2019/07/18/190718cpp/"/>
    <url>/2019/07/18/190718cpp/</url>
    
    <content type="html"><![CDATA[<h1 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a><code>string</code>类型</h1><h2 id="string的定义与声明"><a href="#string的定义与声明" class="headerlink" title="string的定义与声明"></a><code>string</code>的定义与声明</h2><ul><li>初始化<code>string</code>的方法</li></ul><div align=center> <img src="/2019/07/18/190718cpp/1.png" class=""> </div><ul><li>当我们使用<code>=</code>初始化一个变量时，编译器将<code>=</code>右边对象的内容复制到新创建的对象，以进行<strong>拷贝初始化</strong>。当我们省略<code>=</code>时，进行的是直接初始化。</li></ul><h2 id="string上的操作"><a href="#string上的操作" class="headerlink" title="string上的操作"></a><code>string</code>上的操作</h2><ul><li>string的size方法返回一个<code>string::size_type</code>类型的值，该类型是<code>unsigned</code>类型。</li><li>可以将字符字面量和字符串字面量转化为<code>string</code>，将<code>string</code>与字符或字符串字面量拼接时，时<code>+</code>运算符的操作数必须至少有一个为string类型。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">string s1 = <span class="hljs-string">&quot;hello&quot;</span>, s2 = <span class="hljs-string">&quot;world&quot;</span>;<br>string s3 = s1 + <span class="hljs-string">&quot;, &quot;</span> + s2 + <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="处理string中的字符"><a href="#处理string中的字符" class="headerlink" title="处理string中的字符"></a>处理<code>string</code>中的字符</h2><ul><li>定义在<code>cname</code>头文件中的名字在<code>std</code>命名空间中，而定义在<code>.h</code>头文件中的名字则不在<code>std</code>命名空间中。</li><li><p>在以下range <code>for</code>的每一次迭代中，<em>declaration</em>中的变量由<em>expression</em>中下一元素的值初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (declaration : expression)<br>    statement<br></code></pre></td></tr></table></figure></li><li><p>若要在range <code>for</code>中改变<em>expression</em>中元素的值，则需要在<em>declaration</em>中将变量定义为引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello World!!!&quot;</span>)</span></span>;    <span class="hljs-comment">// convert s to uppercase</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : s)    <span class="hljs-comment">// for every char in s (note: c is a reference)</span><br>    c = <span class="hljs-built_in">toupper</span>(c);  <span class="hljs-comment">// c is a reference, so the assignment changes the char in s</span><br>cout &lt;&lt; s &lt;&lt; endl;   <span class="hljs-comment">// HELLO WORLD!!!</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="vector类型"><a href="#vector类型" class="headerlink" title="vector类型"></a><code>vector</code>类型</h1><h2 id="vector的定义与声明"><a href="#vector的定义与声明" class="headerlink" title="vector的定义与声明"></a><code>vector</code>的定义与声明</h2><ul><li>初始化<code>vector</code>的方法</li></ul><div align=center> <img src="/2019/07/18/190718cpp/2.png" class=""> </div><ul><li><p>若<code>vector</code>中的元素为内置类型（例如<code>int</code>），则<code>vector</code>中元素会被初始化为0；若<code>vector</code>中的元素为<code>class</code>类型（例如<code>string</code>）,则<code>vector</code>中元素会进行该元素的默认初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">ivec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    <span class="hljs-comment">// ten elements, each initialized to 0</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">svec</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// ten elements, each an empty string</span><br></code></pre></td></tr></table></figure></li><li><p>对于必需显式初始化的对象，由于没有默认初始化方法，创建该类型的<code>vector</code>时，不能只提供<code>size</code>一个参数。</p></li><li>如果无法进行列初始化，编译器会从根据给定的值寻找其他适合的方法进行初始化。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;string&gt; v5&#123;<span class="hljs-string">&quot;hi&quot;</span>&#125;;     <span class="hljs-comment">// list initialization: v5 has one element</span><br><span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">v6</span><span class="hljs-params">(<span class="hljs-string">&quot;hi&quot;</span>)</span></span>;     <span class="hljs-comment">// error: can&#x27;t construct a vector from a string literal</span><br>vector&lt;string&gt; v7&#123;<span class="hljs-number">10</span>&#125;;       <span class="hljs-comment">// v7 has ten default-initialized elements</span><br>vector&lt;string&gt; v8&#123;<span class="hljs-number">10</span>, <span class="hljs-string">&quot;hi&quot;</span>&#125;; <span class="hljs-comment">// v8 has ten elements with value &quot;hi&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="向vector添加元素"><a href="#向vector添加元素" class="headerlink" title="向vector添加元素"></a>向<code>vector</code>添加元素</h2><ul><li>如果循环体中向<code>vector</code>添加了元素，则不能使用range <code>for</code>。</li></ul><h2 id="vector的其他操作"><a href="#vector的其他操作" class="headerlink" title="vector的其他操作"></a><code>vector</code>的其他操作</h2><ul><li><code>vector</code>（以及<code>string</code>）的下标运算符只能获取已有的元素，不能添加新的元素。</li></ul><h1 id="迭代器（iterators）简介"><a href="#迭代器（iterators）简介" class="headerlink" title="迭代器（iterators）简介"></a>迭代器（iterators）简介</h1><ul><li>若容器是空的，则<code>begin</code>返回与<code>end</code>相同的迭代器。</li><li>大多数迭代器没有<code>&lt;</code>运算符，所以通常在迭代器比较时使用<code>！=</code>。</li><li><code>cbegin</code>和<code>cend</code>返回<code>const_iterator</code>的迭代器，不能修改指向的对象。</li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组的声明与初始化"><a href="#数组的声明与初始化" class="headerlink" title="数组的声明与初始化"></a>数组的声明与初始化</h2><ul><li>数组的维度必须是常量表达式<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">unsigned</span> cnt = <span class="hljs-number">42</span>;          <span class="hljs-comment">// not a constant expression</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">unsigned</span> sz = <span class="hljs-number">42</span>; <span class="hljs-comment">// constant expression</span><br><span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>];                <span class="hljs-comment">// array of ten ints</span><br><span class="hljs-keyword">int</span> *parr[sz];              <span class="hljs-comment">// array of 42 pointers to int</span><br>string bad[cnt];            <span class="hljs-comment">// error: cnt is not a constant expression</span><br>string strs[<span class="hljs-built_in">get_size</span>()];    <span class="hljs-comment">// ok if get_size is constexpr, error otherwise</span><br></code></pre></td></tr></table></figure></li><li>复杂的数组声明<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> *ptrs[<span class="hljs-number">10</span>];            <span class="hljs-comment">//  ptrs is an array of ten pointers to int</span><br><span class="hljs-keyword">int</span> &amp;refs[<span class="hljs-number">10</span>] = <span class="hljs-comment">/* ? */</span>;  <span class="hljs-comment">//  error: no arrays of references</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (*Parray)[<span class="hljs-number">10</span>] = &amp;arr; <span class="hljs-comment">//  Parray points to an array of ten ints</span><br><span class="hljs-built_in"><span class="hljs-keyword">int</span></span> (&amp;arrRef)[<span class="hljs-number">10</span>] = arr;  <span class="hljs-comment">//  arrRef refers to an array of ten ints</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><ul><li><p><code>decltype(ia)</code>返回的是数组类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// ia is an array of ten ints</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(ia)</span></span>; <span class="hljs-comment">// ia2 is an int* that points to the first element in ia</span><br>ia2 = <span class="hljs-number">42</span>;     <span class="hljs-comment">// error: ia2 is a pointer, and we can&#x27;t assign an int to a pointer</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">ia2</span><span class="hljs-params">(&amp;ia[<span class="hljs-number">0</span>])</span></span>;  <span class="hljs-comment">// now it&#x27;s clear that ia2 has type int*</span><br><span class="hljs-keyword">decltype</span>(ia) ia3 = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// ia3 is an array of ten ints</span><br></code></pre></td></tr></table></figure></li><li><p><code>iterator</code>头文件提供了<code>begin</code>与<code>end</code>，分别返回数组的首地址与数组最后一个元素后一位置的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;; <span class="hljs-comment">// ia is an array of ten ints</span><br><span class="hljs-keyword">int</span> *beg = <span class="hljs-built_in">begin</span>(ia); <span class="hljs-comment">// pointer to the first element in ia</span><br><span class="hljs-keyword">int</span> *last = <span class="hljs-built_in">end</span>(ia);  <span class="hljs-comment">// pointer one past the last element in ia</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h2><ul><li>库类型强制要求下标必须为<code>unsigned</code>类型，原始数组无此要求。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> ia[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>&#125;;  <span class="hljs-comment">// array with 5 elements of type int</span><br><span class="hljs-keyword">int</span> *p = &amp;ia[<span class="hljs-number">2</span>];         <span class="hljs-comment">// p points to the element indexed by 2</span><br><span class="hljs-keyword">int</span> k = p[<span class="hljs-number">-2</span>];           <span class="hljs-comment">// p[-2] is the same element as ia[0]</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h2><ul><li><code>string</code>类型的<code>c_str</code>成员函数的返回值可用于初始化C风格字符串，该返回值类型为<code>const char*</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello world&quot;</span>)</span></span>;     <span class="hljs-comment">// s holds Hello World</span><br><span class="hljs-keyword">char</span> *str = s;               <span class="hljs-comment">// error: can&#x27;t initialize a char* from a string</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str = s.<span class="hljs-built_in">c_str</span>(); <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><ul><li>对多维数组使用range <code>for</code>时，除最内层循环之外的循环控制变量必须为引用类型。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP Primer - 变量与基本类型</title>
    <link href="/2019/07/12/190712cpp/"/>
    <url>/2019/07/12/190712cpp/</url>
    
    <content type="html"><![CDATA[<h1 id="原始内置类型"><a href="#原始内置类型" class="headerlink" title="原始内置类型"></a>原始内置类型</h1><h2 id="可运算类型"><a href="#可运算类型" class="headerlink" title="可运算类型"></a>可运算类型</h2><ul><li>最小的可寻址内存块被称为“<strong>字节</strong>”（byte），基本存储单元（通常是几个字节）被称为“<strong>字</strong>”（word）。</li><li>C++虽然一共有3种字符类型（<code>char</code>, <code>signed char</code>, <code>unsigned char</code>），但只有2种表示方式：<code>signed</code>和<code>unsigned</code>，<code>char</code>类型使用其中一种，具体是哪一种取决于编译器。</li><li>当需要使用一个小整数时，显式地使用<code>signed char</code>或<code>unsigned char</code>。</li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>如果向<code>unsiged</code>类型的变量<code>a</code>赋超过其表示范围的值<code>b</code>，结果是<code>b % 变量a类型的存储范围</code>；如果向<code>siged</code>类型的变量<code>a</code>赋超过其表示范围的值<code>b</code>，结果是<strong>未定义的</strong>。</li><li>如果在算术表达式中同时使用<code>unsigned</code>类型和<code>singed</code>类型，<code>singed</code>类型将被自动转换为<code>unsinged</code>类型。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">unsigned</span> u = <span class="hljs-number">10</span>, u2 = <span class="hljs-number">42</span>;<br>std::cout &lt;&lt; u2 - u &lt;&lt; std::endl;    <span class="hljs-comment">// 32</span><br>std::cout &lt;&lt; u - u2 &lt;&lt; std::endl;    <span class="hljs-comment">// 4294967264</span><br><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>, i2 = <span class="hljs-number">42</span>;<br>std::cout &lt;&lt; i2 - i &lt;&lt; std::endl;    <span class="hljs-comment">// 32</span><br>std::cout &lt;&lt; i - i2 &lt;&lt; std::endl;    <span class="hljs-comment">// -32</span><br><br>std::cout &lt;&lt; i - u &lt;&lt; std::endl;     <span class="hljs-comment">// 0</span><br>std::cout &lt;&lt; u - i &lt;&lt; std::endl;     <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><ul><li>默认情况下，十进制字面量是<code>signed</code>类型，而八进制和十六进制字面量可以是<code>signed</code>类型也可以是<code>unsigned</code>类型。</li><li><p>虽然整数字面量存储于<code>signed</code>类型，但十进制字面量的值永远不会是一个负数。例如，<code>-42</code>中，负号不是字面量的一部分。</p></li><li><p>默认情况下，浮点型字面量的类型是<code>double</code>。</p></li><li>两个仅由空格、tab或者换行符分隔的字符串字面量会被拼接为一个字面量。</li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><ul><li><p>初始化和赋值在C++中是两个不同的操作。</p></li><li><p>可以用以下4种方法定义一个名为<code>units_sold</code>的变量，并将其初始化为0，其中使用<code>&#123;&#125;</code>的第2、3种称为<strong>列初始化</strong>（list initialization）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> units_sold = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> units_sold = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">int</span> units_sold&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">units_sold</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>使用会产生信息丢失的值进行列初始化是非法的。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span> ld = <span class="hljs-number">3.14159265356</span>;<br><span class="hljs-keyword">int</span> a&#123;ld&#125;, b = &#123;ld&#125;;  <span class="hljs-comment">//error: narrowing conversion required</span><br>int c(ld), d = ld;    //ok: but value will be truncated<br></code></pre></td></tr></table></figure></li><li><p>在函数体外定义的变量会被初始化为0，在函数内定义的变量是<strong>未初始化的</strong>（uninitialized）。</p></li></ul><h2 id="变量声明与定义"><a href="#变量声明与定义" class="headerlink" title="变量声明与定义"></a>变量声明与定义</h2><ul><li><p>为了支持分离编译，C++将声明与定义区分开。<strong>声明</strong>（declaration）使程序知道变量的存在，一个文件若想使用在别处定义的变量，则需在文件中包含对该变量的声明；<strong>定义</strong>（definition）创建相应的变量。</p></li><li><p>使用<code>extern</code>关键字但不提供显式初始化则可获得一个声明而非定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> i;    <span class="hljs-comment">// declares but does not define i</span><br><span class="hljs-keyword">int</span> j;           <span class="hljs-comment">// declares and define j</span><br></code></pre></td></tr></table></figure></li><li><p>任何包含显式初始化的声明都是一个定义，带有初始化的<code>extern</code>声明是一个定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.1416</span>;    <span class="hljs-comment">//definition</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul><li>全局命名空间没有名字，因此，可用<code>::val_name</code>访问全局命名空间中的名字。</li></ul><h1 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>引用的类型与引用所指向对象的类型必须匹配（有2个例外）。</li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>指针的类型与指针所指向对象的类型必须匹配（有2个例外）。</li><li><p>将<code>int</code>类型的变量赋给指针是非法的，即使该变量的值恰好为0。</p></li><li><p>不使用一个<code>void *</code>对其指向的对象进行操作——因为我们无法知道对象的类型。</p></li></ul><h2 id="理解复合类型说明"><a href="#理解复合类型说明" class="headerlink" title="理解复合类型说明"></a>理解复合类型说明</h2><ul><li>理解一个引用<code>r</code>最好的方式是，从右到左地读它的定义。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">int</span> *p;            <span class="hljs-comment">// p is a pointer to int</span><br><span class="hljs-keyword">int</span> *&amp;r = p;       <span class="hljs-comment">// r is a reference to the pointer p</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="const"><a href="#const" class="headerlink" title="const"></a><code>const</code></h1><ul><li>当我们在多个文件中用相同的名字定义一个const时，这就像在每一个文件中定义了一个不同的变量。</li></ul><h2 id="const修饰的引用"><a href="#const修饰的引用" class="headerlink" title="const修饰的引用"></a><code>const</code>修饰的引用</h2><ul><li>“引用的类型与引用所指向对象的类型必须匹配”的第一个例外是：我们可以用任何可转换为引用的类型的表达式来初始化一个<code>const</code>修饰的引用。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r1 = i;        <span class="hljs-comment">// we can bind a const int&amp; to a plain int object</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r2 = <span class="hljs-number">42</span>;       <span class="hljs-comment">// ok: r2 is a reference to const</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;r3 = r1 * <span class="hljs-number">2</span>;   <span class="hljs-comment">// ok: r3 is a reference to const</span><br><span class="hljs-keyword">int</span> &amp;r4 = r * <span class="hljs-number">2</span>;          <span class="hljs-comment">// error: r4 is a plain, non const reference</span><br><br><span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ri = dval;     <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="指针与const"><a href="#指针与const" class="headerlink" title="指针与const"></a>指针与<code>const</code></h2><ul><li>一个<code>const</code>变量的地址只能存储在用const修饰的指针中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> pi = <span class="hljs-number">3.14</span>;    <span class="hljs-comment">// pi is const; its value may not be changed</span><br><span class="hljs-keyword">double</span> *ptr = &amp;pi;         <span class="hljs-comment">// error: ptr is a plain pointer</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *cptr = &amp;pi;  <span class="hljs-comment">// ok: cptr may point to a double that is const</span><br>*cptr = <span class="hljs-number">42</span>;                <span class="hljs-comment">// error: cannot assign to *cptr</span><br></code></pre></td></tr></table></figure></li><li>“指针的类型与指针所指向对象的类型必须匹配”的第一个例外是：我们可以用一个<code>const</code>修饰的指针指向一个非<code>const</code>的对象。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> dval = <span class="hljs-number">3.14</span>;         <span class="hljs-comment">// dval is a double; its value can be changed</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> *cptr = &amp;dval; <span class="hljs-comment">// ok: but can&#x27;t change dval through cptr</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="Top-Level-const"><a href="#Top-Level-const" class="headerlink" title="Top-Level const"></a>Top-Level const</h2><ul><li><strong>Top-level const</strong>是指指针本身是<code>const</code>，<strong>low-level const</strong>是指指针可指向一个<code>const</code>对象。</li></ul><h2 id="constexpr与常量表达式"><a href="#constexpr与常量表达式" class="headerlink" title="constexpr与常量表达式"></a><code>constexpr</code>与常量表达式</h2><ul><li><strong>常量表达式</strong>是值不能改变，并且值能够在编译时确定的表达式。</li><li><p>一个由常量表达式初始化的const对象也是一个常量表达式。</p></li><li><p>可以用<code>constexpr</code>函数初始化一个<code>constexpr</code>变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> max_files = <span class="hljs-number">20</span>;        <span class="hljs-comment">// max_files is a constant expression</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> limit = max_files + <span class="hljs-number">1</span>; <span class="hljs-comment">// limit is a constant expression</span><br><span class="hljs-keyword">int</span> staff_size = <span class="hljs-number">27</span>;             <span class="hljs-comment">// staff_size is not a constant expression</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> sz = <span class="hljs-built_in">get_size</span>();       <span class="hljs-comment">// sz is not a constant expression</span><br></code></pre></td></tr></table></figure></li><li><p>可以在<code>constexpr</code>中使用的类型称为“字面类型”。</p></li><li>在函数外定义的变量的地址是常量表达式，可用于初始化<code>constexpr</code>指针。</li><li>当我们在一个指针声明中使用<code>constexpr</code>时，<code>constexpr</code>修饰符应用于指针本身，而不是指针所指向的变量。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = <span class="hljs-literal">nullptr</span>;        <span class="hljs-comment">// p is a pointer to a const int</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> *q = <span class="hljs-literal">nullptr</span>;    <span class="hljs-comment">// q is a const pointer to int</span><br></code></pre></td></tr></table></figure></li></ul><p><code>constexpr</code>引入的是top-level <code>const</code>。</p><h1 id="类型处理"><a href="#类型处理" class="headerlink" title="类型处理"></a>类型处理</h1><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><ul><li><p>使用<code>typedef</code>定义类型别名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">double</span> wages;    <span class="hljs-comment">// wages is a synonym for double</span><br><span class="hljs-keyword">typedef</span> wages base, *p;  <span class="hljs-comment">// base is a synonym for double, p for double*</span><br></code></pre></td></tr></table></figure></li><li><p>使用<strong>类型声名</strong>定义类型别名：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> SI = Sales_item;   <span class="hljs-comment">// SI is a synonym for Sales_item</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a><code>decltype</code></h2><ul><li><p><code>decltype</code>是唯一处理引用本身，而不是引用指向对象的语法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> ci = <span class="hljs-number">0</span>, &amp;cj = ci;<br><span class="hljs-keyword">decltype</span>(ci) x = <span class="hljs-number">0</span>; <span class="hljs-comment">// x has type const int</span><br><span class="hljs-keyword">decltype</span>(cj) y = x; <span class="hljs-comment">// y has type const int&amp; and is bound to x</span><br><span class="hljs-keyword">decltype</span>(cj) z;     <span class="hljs-comment">// error: z is a reference and must be initialized</span><br></code></pre></td></tr></table></figure></li><li><p>通常，<code>decltype</code>对产生左值的表达式返回一个引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// decltype of an expression can be a reference type</span><br><span class="hljs-keyword">int</span> i = <span class="hljs-number">42</span>, *p = &amp;i, &amp;r = i;<br><span class="hljs-keyword">decltype</span>(r + <span class="hljs-number">0</span>) b;  <span class="hljs-comment">// ok: addition yields an int; b is an (uninitialized) int</span><br><span class="hljs-keyword">decltype</span>(*p) c;     <span class="hljs-comment">// error: c is int&amp; and must be initialized</span><br></code></pre></td></tr></table></figure></li><li><p>如果对一个变量名加上一组或多组圆括号，编译器会将该操作数当作表达式，<code>decltype</code>会对这样的表达式产生一个引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// decltype of a parenthesized variable is always a reference</span><br><span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">decltype</span>((i)) d;    <span class="hljs-comment">// error: d is int&amp; and must be initialized</span><br><span class="hljs-keyword">decltype</span>(i) e;      <span class="hljs-comment">// ok: e is an (uninitialized) int</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="定义自己的数据结构"><a href="#定义自己的数据结构" class="headerlink" title="定义自己的数据结构"></a>定义自己的数据结构</h1><ul><li>没有初始化器的类成员会被默认初始化。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPP Primer  -  Getting Started</title>
    <link href="/2019/07/09/190709cpp/"/>
    <url>/2019/07/09/190709cpp/</url>
    
    <content type="html"><![CDATA[<h1 id="查看main函数的返回值"><a href="#查看main函数的返回值" class="headerlink" title="查看main函数的返回值"></a>查看<code>main</code>函数的返回值</h1><p>在大多数系统中，<code>main</code>函数的返回值是一个状态指示器。返回值为0意味着成功，非0返回值的意义由系统定义，通常一个非0返回值指示了发生错误的种类。<code>main</code>函数返回值的获取方式是由系统决定的，在UNIX系统中，通过以下指令可获取main函数的返回值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $?<br></code></pre></td></tr></table></figure><h2 id="编写代码进行测试"><a href="#编写代码进行测试" class="headerlink" title="编写代码进行测试"></a>编写代码进行测试</h2><p>这是一个最简单的C++程序，直接返回0。</p><figure class="highlight c++"><figcaption><span>main_only.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在终端编译运行，并查看返回值。</p><div align=center> <img src="/2019/07/09/190709cpp/1.png" class=""> </div><p>可见<code>echo $?</code>正确地输出了<code>main</code>函数的返回值。</p><h2 id="将返回值修改为-1"><a href="#将返回值修改为-1" class="headerlink" title="将返回值修改为-1"></a>将返回值修改为-1</h2><figure class="highlight c++"><figcaption><span>main_only.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新编译运行：</p><div align=center> <img src="/2019/07/09/190709cpp/2.png" class=""> </div><p>这次<code>echo $?</code>没有正确地输出-1，而是输出了255，推测原因是存储该值的变量是一个8位无符号整数。</p><h2 id="将返回值修改为257"><a href="#将返回值修改为257" class="headerlink" title="将返回值修改为257"></a>将返回值修改为257</h2><figure class="highlight c++"><figcaption><span>main_only.cc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">257</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>若存储程序返回状态的变量是8位无符号整数，那么该程序运行后，<code>echo $?</code>将输出1，验证这一想法：</p><p><img src="190709cpp/3.png" alt=""></p><h1 id="std-cout缓冲"><a href="#std-cout缓冲" class="headerlink" title="std::cout缓冲"></a><code>std::cout</code>缓冲</h1><p>C++中的IO操作通常将数据先存储在缓冲区。输出缓冲可以被显式地冲洗，以将缓冲区中的数据写入文件。</p><p><em>C++ Primer</em>第一章提到了3种会冲洗<code>std::cout</code>缓冲的情况：</p><ul><li>使用<code>std::endl</code>操作符(manipulator)</li><li>读取<code>std::cin</code></li><li>程序结束时，自动冲洗</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++ Primer</tag>
      
      <tag>RE：从零开始的C++学习</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
